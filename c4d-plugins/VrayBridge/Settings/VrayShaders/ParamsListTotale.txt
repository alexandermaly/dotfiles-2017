Parameters for plugin 'TexParticleSampler'
  rgbPP: output acolor texture, Per-particle color.
  incandescencePP: output acolor texture, Per-particle emission/incandescence.
  acceleration: output acolor texture, Per-particle acceleration.
  userVector1PP: output acolor texture, Per-particle user color 1.
  userVector2PP: output acolor texture, Per-particle user color 2.
  userVector3PP: output acolor texture, Per-particle user color 3.
  userVector4PP: output acolor texture, Per-particle user color 4.
  userVector5PP: output acolor texture, Per-particle user color 5.
  age: output float texture, Per-particle age.
  lifespanPP: output float texture, Per-particle lifespan.
  opacityPP: output float texture, Per-particle opacity.
  userScalar1PP: output float texture, Per-particle user scalar 1.
  userScalar2PP: output float texture, Per-particle user scalar 2.
  userScalar3PP: output float texture, Per-particle user scalar 3.
  userScalar4PP: output float texture, Per-particle user scalar 4.
  userScalar5PP: output float texture, Per-particle user scalar 5.


Parameters for plugin 'TexParticleDiffuse'


Parameters for plugin 'TexEdges'
  edges_tex: acolor texture = AColor(1, 1, 1, 1)
  bg_tex: acolor texture = AColor(0, 0, 0, 1)
  show_hidden_edges: bool = false
  width_type: integer = 0, 0 : World units, 1 : Pixels
  world_width: float = 1
  pixel_width: float = 1


Parameters for plugin 'TexSky'
  transform: transform
  target_transform: transform
  turbidity: float = 3
  ozone: float = 0.35
  water_vapour: float = 2
  intensity_multiplier: float = 1
  size_multiplier: float = 1
  up_vector: vector = Color(0, 0, 0)
  invisible: bool = false
  horiz_illum: float = 25000
  sky_model: integer = 0
  sun: plugin, If specified, all parameters are taken from the sun; otherwise, the sky parameters are used


Parameters for plugin 'SunLight'
  transform: transform
  target_transform: transform
  turbidity: float = 3
  ozone: float = 0.35
  water_vapour: float = 2
  intensity_multiplier: float = 1
  size_multiplier: float = 1
  up_vector: vector = Color(0, 0, 0)
  invisible: bool = false
  horiz_illum: float = 25000
  sky_model: integer = 0
  shadows: bool = true, true if the light casts shadows and false otherwise
  atmos_shadows: bool = true, true if the light casts shadows from atmosperics and false otherwise
  shadowBias: float = 0, Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
  shadow_subdivs: integer = 8
  shadow_color: color = Color(0, 0, 0), The shadow color. Anything but black is not physically accurate.
  shadow_color_tex: acolor texture, A color texture that if present will override the shadowColor parameter
  photon_radius: float = 50
  photonSubdivs: integer = 500
  causticSubdivs: integer = 1000
  diffuseMult: float = 1
  causticMult: float = 1
  enabled: bool = true, true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
  affectDiffuse: bool = true, true if the light produces diffuse lighting and false otherwise
  affectSpecular: bool = true, true if the light produces specular hilights and false otherwise
  diffuse_contribution: float = 1, Diffuse contribution for the light
  specular_contribution: float = 1, Specular contribution for the light
  channels: plugin, unlimited list, Render channels the result of this light will be written to
  channels_raw: plugin, unlimited list, Render channels the raw diffuse result of this light will be written to
  channels_diffuse: plugin, unlimited list, Render channels the diffuse result of this light will be written to
  channels_specular: plugin, unlimited list, Render channels the specular result of this light will be written to


Parameters for plugin 'SphereFadeGizmo'
  transform: transform
  radius: float = 1


Parameters for plugin 'SphereFade'
  gizmos: plugin, unlimited list, List of gizmos
  empty_color: color = Color(0.5, 0.5, 0.5)
  affect_alpha: bool = false
  falloff: float = 0.2


Parameters for plugin 'VolumeMulti'
  volumes: plugin, unlimited list


Parameters for plugin 'VolumeScatterFog'
  emission: color = Color(0, 0, 0), Fog emission color
  color: color = Color(0.5, 0.5, 0.5), Fog color
  color_mult: float = 0.1, Fog color multiplier
  ior: float = 1, The IOR for the volume
  bias: float = 0, Bias for the fogging distance
  subdivs: integer = 8, Subdivs for the scattering samples
  thickness: float = 1e+18, Maximum distance to trace into the objects
  light_mult: float = 1, Multiplier for the sss effect
  scatter_coeff: float = 0, Scatter coefficient (0.0 is full scattering; 1.0 is purely directional)
  scatter_direction: float = 1, Scatter direction (0.0 is forward away from the viewer; 1.0 is backward towards the viewer)
  scatter_levels: integer = 1, Maximum number of scattering bounces
  environment_fog: bool = false, true if this is environment fog and false if it is inside an object


Parameters for plugin 'VolumeFog'
  emission: color = Color(0, 0, 0), Fog emission color
  color: color = Color(0.5, 0.5, 0.5), Fog color
  color_mult: float = 0.1, Fog color multiplier
  ior: float = 1, The IOR for the volume
  bias: float = 0, Bias for the fogging distance


Parameters for plugin 'EnvFogMeshGizmo'
  transform: transform
  geometry: plugin
  lights: plugin, unlimited list
  fade_out_radius: float = 0, fade out effect for the edges


Parameters for plugin 'EnvironmentFog'
  gizmos: plugin, unlimited list, List of gizmos
  emission: color = Color(0, 0, 0), Fog emission color
  emission_tex: acolor texture, Fog emission texture
  emission_mult: float = 1, Fog emission multiplier
  emission_mult_tex: float texture, Fog emission texture multiplier
  color: color = Color(0, 0, 0), Fog color
  color_tex: acolor texture, Fog texture
  distance: float = 10, Distance between fog particles
  density: float = 1, Fog density
  density_tex: float texture, Texture for fog density
  use_height: bool = true, Whether or not the height should be taken into account.
  height: float = 100, Fog starting point along the Z-axis.
  subdivs: integer = 8, Fog subdivision
  yup: bool = false, if true, y is the up axis, not z
  fade_out_mode: integer = 0, fade out mode 0: multiply, 1: substract
  fade_out_radius: float = 0, fade out effect for the edges
  per_object_fade_out_radius: bool = false, fade out effect for the edges per object
  use_fade_out_tex: bool = true, True if the fade_out_tex should be used for fade out computation.
  fade_out_tex: float texture, If use_fade_out_tex is true and this is specified, it will override the default fade out computation.
  edge_fade_out: float = 0, Used with the fade_out_tex, mimics Maya fluid's edge dropoff attribute
  fade_out_type: integer = 0, 0 - used for the gradients and the grid falloff(fadeout);1 - used for the sphere, cone and double cone types;2 - used for the cube type, the computations are done in the TexMayaFluidProcedural plug-in;
  scatter_gi: bool = false, Scatter global illumination
  scatter_bounces: integer = 8, Number of GI bounces calculated inside the fog
  simplify_gi: bool = false, Simplify global illumination
  step_size: float = 1, Size of one step through the volume
  max_steps: integer = 1000, Maximum number of steps through the volume
  tex_samples: integer = 4, Number of texture samples for each step through the volume
  cutoff_threshold: float = 0.001, Controls when the raymarcher will stop traversing the volume.
  light_mode: integer = 1, light mode 0: no lights, 1: Use per-gizmo lights, 2: Override per-gizmo lights, 3: Intersect with per-gizmo lights, 4: Add to per-gizmo lights
  lights: plugin, unlimited list
  use_shade_instance: bool = false, True if the shade instance should be used when sampling textures.
  affect_background: bool = false, Affect background
  affect_reflections: bool = true, true if the fog is visible to reflection rays
  affect_refractions: bool = true, true if the fog is visible to refraction rays
  affect_shadows: bool = true, true if the fog affects shadow rays
  affect_gi: bool = true, true if the fog affects GI rays
  affect_camera: bool = true, true if the fog affects primary camera rays


Parameters for plugin 'UVWGenProjection'
  uvw_transform: transform
  uvw_transform_tex: transform texture
  tex_transform: transform
  type: integer = 1, Mapping type (0 - none; 1 - planar; 2 - spherical; 3 - cylindrical; 4 - ball; 5 - cubic; 6 - triplanar; 8 - perspective
  u_angle: float = 3.14159
  v_angle: float = 1.5708
  camera_settings: plugin
  camera_view: plugin
  fitfill: integer = 0, 0 - Fit fill; 1 - Horizontal; 2 - Vertical;
  fittype: integer = 0, 0 - None; 1 - Match camera film gate; 2 - Match camera resolution;
  bitmap: plugin, If we are projecting a bitmap, this is the bitmap's buffer, we need it to implement vertical/horizontal fit
  film_gate_w: float = 1
  film_gate_h: float = 1


Parameters for plugin 'UVWGenPlanarWorld'
  uvw_transform: transform, Initial transformation on the uvw coordinates, before mirror, crop etc
  uvw_transform_tex: transform texture
  tex_transform: transform, Final transformation on the resulting uvw coordinates, after mirror, crop etc
  nsamples: integer = 0, Number of uvw transform samples
  wrap_u: integer = 0, 0 - no wrapping, 1 - wrap, 2 - mirror tile
  wrap_v: integer = 0, 0 - no wrapping, 1 - wrap, 2 - mirror tile
  wrap_w: integer = 0, 0 - no wrapping, 1 - wrap, 2 - mirror tile
  crop_u: integer = 0, 1 to crop in the u-direction
  crop_v: integer = 0, 1 to crop in the v-direction
  crop_w: integer = 0, 1 to crop in the w-direction
  coverage: vector = Color(0, 0, 0), Coverage
  uvw_coords: output vector texture, The uvw coordinates for the specified channel at the current shading point
  wrap_mode: integer = 0, Wrap mode (0 - wrap on 0.5 boundary; 1 - wrap on integer boundary
  duvw_scale: float = 1, Additional scale factor for the texture derivatives


Parameters for plugin 'UVWGenObject'
  uvw_transform: transform
  duvw_scale: float = 1, Additional scale factor for the texture derivatives


Parameters for plugin 'UVWGenExplicit'
  u: float texture, the U input
  v: float texture, the V input
  w: float texture, the W input
  uvw: acolor texture


Parameters for plugin 'UVWGenEnvironment'
  uvw_matrix: matrix, Transformation of the input directions
  uvw_transform: transform, Transformation of the resulting UVW coordinates
  mapping_type: string = "spherical", One of "angular", "cubic", "spherical", "mirror_ball", "screen", "max_spherical", "spherical_vray", "max_cylindrical" or "max_shrink_wrap"
  wrap_u: integer = 0, 0 - no wrapping, 1 - wrap, 2 - mirror tile
  wrap_v: integer = 0, 0 - no wrapping, 1 - wrap, 2 - mirror tile
  wrap_w: integer = 0, 0 - no wrapping, 1 - wrap, 2 - mirror tile
  crop_u: integer = 0, 1 to crop in the u-direction
  crop_v: integer = 0, 1 to crop in the v-direction
  crop_w: integer = 0, 1 to crop in the w-direction
  duvw_scale: float = 1, Additional scale factor for the texture derivatives


Parameters for plugin 'UVWGenChannel'
  uvw_transform: transform, Initial transformation on the uvw coordinates, before mirror, crop etc
  uvw_transform_tex: transform texture
  tex_transform: transform, Final transformation on the resulting uvw coordinates, after mirror, crop etc
  nsamples: integer = 0, Number of uvw transform samples
  wrap_u: integer = 0, 0 - no wrapping, 1 - wrap, 2 - mirror tile
  wrap_v: integer = 0, 0 - no wrapping, 1 - wrap, 2 - mirror tile
  wrap_w: integer = 0, 0 - no wrapping, 1 - wrap, 2 - mirror tile
  crop_u: integer = 0, 1 to crop in the u-direction
  crop_v: integer = 0, 1 to crop in the v-direction
  crop_w: integer = 0, 1 to crop in the w-direction
  coverage: vector = Color(0, 0, 0), Coverage
  uvw_coords: output vector texture, The uvw coordinates for the specified channel at the current shading point
  wrap_mode: integer = 0, Wrap mode (0 - wrap on 0.5 boundary; 1 - wrap on integer boundary
  duvw_scale: float = 1, Additional scale factor for the texture derivatives
  uvw_channel: integer = 1
  uvwgen: plugin, Optional UVWGen from which the initial uvw coordinates will be taken, instead of the surface point


Parameters for plugin 'VolumeVRayToon'
  lineColor: color = Color(0, 0, 0), The color of cartoon line
  widthType: integer = 0
  lineWidth: float = 1.5
  opacity: float = 1
  hideInnerEdges: bool = false
  normalThreshold: float = 0.7
  overlapThreshold: float = 0.95
  traceBias: float = 0.2
  doSecondaryRays: bool = false
  excludeType: bool = true
  excludeList: plugin, unlimited list
  lineColor_tex: acolor texture
  lineWidth_tex: float texture
  opacity_tex: float texture
  distortion_tex: float texture


Parameters for plugin 'texRenderHair'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  use_3d_mapping: bool = true
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  a_color_tex: acolor texture, Defines the main diffuse color of the hair strand’s tips.
  b_color_tex: acolor texture, Defines a secondary diffuse color for the hair strand’s tips. This provides an alternate color that gets added to random hair strands. 
  root_color_tex: acolor texture, Defines the diffuse color of the hair roots
  root_crossover_tex: float texture, A value of 0 is mostly Tip and 1 is mostly Root


Parameters for plugin 'TexXSIMulti'
  textures: plugin, unlimited list, A list of float textures
  ids_list: integer, unlimited list, A list of material IDs


Parameters for plugin 'TexXSIScalarInvert'
  input: float texture, Specifies the input value to be inverted


Parameters for plugin 'TexXSIColorBalance'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  xsi_color: acolor texture, Input texture
  shadows_red: float = 0
  shadows_green: float = 0
  shadows_blue: float = 0
  midtones_red: float = 0
  midtones_green: float = 0
  midtones_blue: float = 0
  highlights_red: float = 0
  highlights_green: float = 0
  highlights_blue: float = 0
  preserve_value: integer = 0


Parameters for plugin 'TexXSIRGBAKeyer'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  xsi_color: acolor texture, Input texture
  min_thresh: acolor texture, Minimum threshold
  max_thresh: acolor texture, Maximum threshold
  inrange: acolor texture, Color if in range
  outrange: acolor texture, Color if outside range
  alpha: integer = 0, Include alpha


Parameters for plugin 'TexXSIHLSAdjust'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  xsi_color: acolor texture, Input texture
  master_h: float = 0, master hue
  master_l: float = 0, master lightness
  master_s: float = 0, master saturation
  red_h: float = 0, red hue
  red_l: float = 0, red lightness
  red_s: float = 0, red saturation
  green_h: float = 0, green hue
  green_l: float = 0, green lightness
  green_s: float = 0, green saturation
  blue_h: float = 0, blue hue
  blue_l: float = 0, blue lightness
  blue_s: float = 0, blue saturation
  cyan_h: float = 0, cyan hue
  cyan_l: float = 0, cyan lightness
  cyan_s: float = 0, cyan saturation
  yellow_h: float = 0, yellow hue
  yellow_l: float = 0, yellow lightness
  yellow_s: float = 0, yellow saturation
  magenta_h: float = 0, yellow hue
  magenta_l: float = 0, yellow lightness
  magenta_s: float = 0, yellow saturation


Parameters for plugin 'TexXSIIntensity'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  xsi_color: acolor texture, Color or Texture
  factor: float = 1, multiply factor


Parameters for plugin 'TexXSINormalMap'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  xsi_color: acolor texture, Color or Texture
  tangents: acolor texture, Vertex color map
  dir_tex: acolor texture, Direction texture of type (r, 0, 0)
  TangentsAreUnbiased: integer = 0, Unbiased Tangents


Parameters for plugin 'TexXSISnow'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  snow_col: acolor texture
  surface_col: acolor texture
  threshold: float = 0.9
  depth_decay: float = 5
  thickness: float = 0.7
  randomness: float = 0.5
  rand_freq: float = 15


Parameters for plugin 'TexXSIFalloff'
  curve_falloff: float = 1, Curve falloff
  facing_refl: float = 1, Facing reflectivity
  perp_refl: float = 1, Perpendicular reflectivity
  white_color: acolor texture, Refraction (front) color
  black_color: acolor texture, Reflection (side) color


Parameters for plugin 'TexXSIFlagstone'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  color2: acolor texture
  color1: acolor texture
  mortar_width: float = 0.05


Parameters for plugin 'TexXSIColorMix'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  xsi_color: acolor texture, Color or Texture
  xsi_scale: float = 1, Scale color parameter
  use_alpha: bool = false, Use alpha of the texture as return greyscale value
  xsi_invert: bool = false, Invert
  fix_alpha_to_1: bool = false, Make result alpha 1


Parameters for plugin 'TexColorSwitch'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  default_color: acolor texture, Default color to be used when the Switch value does not match the Value of any of the Cases
  switch_value: integer = 0, Accepts a varying set of integer values that control which Case’s Input gets evaluated
  color0: acolor texture
  value0: integer = 0
  color1: acolor texture
  value1: integer = 1
  color2: acolor texture
  value2: integer = 2
  color3: acolor texture
  value3: integer = 3
  color4: acolor texture
  value4: integer = 4
  color5: acolor texture
  value5: integer = 5
  color6: acolor texture
  value6: integer = 6
  color7: acolor texture
  value7: integer = 7


Parameters for plugin 'TexXSIRipple'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  use_3d_mapping: bool = true
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  color1: acolor texture
  color2: acolor texture
  Amplitude: float = 1
  Origin: vector = Color(0, 0, 0)
  Time: float = 1
  Frequency: float = 10
  Decay: float = 0
  Group_Velocity: float = 0
  Phase_Velocity: float = 0
  Spread_Start: float = 1
  Spread_Rate: float = 0


Parameters for plugin 'texXSIColor2Vector'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  clr_txt: acolor texture, Scalar2Vector will be calculated on the base of a color texture
  output_scale: float texture, list of 1 elements, The intensity to output
  method: integer = 0, method: direct copy(0), normal map(1)


Parameters for plugin 'texXSIColor2Alpha'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  clr_txt: acolor texture, Scalar2Alpha will be calculated on the base of a color texture
  intensity_txt: float texture, The intensity to output


Parameters for plugin 'TexXSIScalar2Color'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  clr_txt: acolor texture, Scalar2Color will be calculated on the base of a color or float texture
  float_txt: float texture, Specifies the input scalar value (value between 0 and 1) to be copied to RGB channels
  alpha: float = 1, Specifies the input scalar value to be copied to the alpha channel of the output


Parameters for plugin 'TexColor2Scalar'
  clr_txt: acolor texture, Color texture, which intensity will be used
  mult: float texture, intensity multiplier
  use_alpha: integer = 0, add alpha in the average calculation


Parameters for plugin 'TexBillboardParticle'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  clr_txt: acolor texture, Color texture, the particles'color
  NormalType: integer = 0, Surface Normal Type: Billboard or Spherical
  Direction: integer = 0, Face Direction: Camera, Incoming ray, Camera and Lights, Use Rotation
  TextureSpace: integer = 0, Planar, Particle’s Local Space, Cloud’s Local Space, World Space
  Shape: integer = 0, Shape: Square, Rectangular or Circular
  FollowVelocity: integer = 0, Particle billboard rotates in the direction of the velocity. This is disabled if the billboard Face Direction is set to Use Rotation
  SelfShadow: float = 1, Shadows cast by the particles onto themselves are attenuated by this factor
  UseShading: integer = 0, Applies a simple shading model to the particles. If not selected, only shadows are calculated, and the particles are still visible even if no lights are applied to the cloud.
  AmbientType: integer = 0, % of Base Color (particle type color), Use Ambient Color (the values of the Color sliders below), or None.
  AmbienceClr: acolor texture, Ambience colour
  AmbientClr: acolor texture, Ambient colour
  AmbientPart: float = 1, Ambient % of base
  SpecularType: integer = 0, Specular type (0 = none, 1 = colour, 2 = % of base 
  SpecularClr: acolor texture, Specular colour
  SpecularPart: float = 1, Specular % of base
  SpecularCoeff: float = 1, Specular coeff
  IrradianceType: integer = 0, Irradiance type (0 = none, 1 = colour, 2 = % of base 
  IrradianceClr: acolor texture, Irradiance colour
  IrradiancePart: float = 1, Irradiance % of base
  RadianceType: integer = 0, Radiance type (0 = none, 1 = colour, 2 = % of base 
  RadianceClr: acolor texture, Radiance colour
  RadiancePart: float = 1, Radiance % of base
  ColourBurn: float = 0, Amount of colour burn to apply


Parameters for plugin 'TexXSIColorCorrection'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  xsi_color: acolor texture, Input texture
  gamma: float = 1, Used to compensate for non-linearity in displays. Often used as a general brightness control.
  contrast: float = 0.5, Increases and decreases the contrast levels between light and dark colors. 0.5 = no change in contrast
  hue: float = 0, Controls a 360 degrees hue shift through the HLS color space spectrum without modifying the intensity or saturation of the color
  saturation: float = 0, Adjusts the saturation, or amount of <pigment> in a color. A value of 1 results in no white and all color; a value of 0 results in no color, just white light
  level: float = 0, Adjusts the level or luminance of a color. Similar to intensity or brightness


Parameters for plugin 'TexParticleShape'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  clr_txt: acolor texture, Color texture, the particles'color
  Falloff: integer = 0, Falloff Type - None(0), Linear(1), Square(2), Smooth(3), Cubic(4), Gaussian(5), User-defined(6)
  FalloffX: float = 0.5
  FalloffY: float = 0.5
  FalloffRGB: integer = 0
  FalloffAlpha: integer = 1
  FalloffRGBInvert: integer = 0
  FalloffAlphaInvert: integer = 0
  FalloffStart: float = 0
  FalloffEnd: float = 1
  Exponent: float = 3
  GaussRate: float = 1
  Shape: integer = 0, Shape - None(0), Step(1), Sine(2), Star3), Beam(4), Symmetry(5), Noise(6), Turbulence(7), Fractal(8)
  ShapeX: float = 0.5
  ShapeY: float = 0.5
  ShapeRGB: integer = 0
  ShapeAlpha: integer = 1
  ShapeRGBInvert: integer = 0
  ShapeAlphaInvert: integer = 0
  StepWidth: float = 0.4
  SineScale: float = 11
  StarBranches: float = 4
  BeamWidth: float = 0.02
  SymmetryWidth: float = 0.2
  NoiseTime: float = 0
  NoiseScale: float = 1
  TurbTime: float = 0
  TurbScale: float = 1
  TurbLoFreq: float = 1
  TurbHiFreq: float = 4
  FracTime: float = 0
  FracScale: float = 0.4
  FracWeight: float = 0.5
  FracGranular: float = 1
  FracOctave: integer = 4


Parameters for plugin 'TexXSIFabric'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  use_3d_mapping: bool = true
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  uthread_color: acolor texture
  vthread_color: acolor texture
  gap_color: acolor texture
  uthread_width: float = 0.5
  vthread_width: float = 0.5
  u_wave: float = 0.5
  v_wave: float = 0.5
  randomness: float = 0.5
  width_variation: float = 0.5
  bright_variation: float = 0.5


Parameters for plugin 'TexXSIVein'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  use_3d_mapping: bool = true
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  color1: acolor texture
  color2: acolor texture
  complexity: float = 2
  thickness: float = 0.5
  falloff: float = 0.5
  sharpness: float = 0.5
  intensity: float = 1
  time: float = 0


Parameters for plugin 'TexDisplacacementRestrict'
  input_tex: float texture, Input Float Texture
  max_displacement: float = -1, Specifies the maximum displacement value.  If an input value is higher than the Max Displacement value, it will be clipped


Parameters for plugin 'TexInterpLinear'
  input: float texture, scalar value to be remapped
  oldrange_min: float texture, start of the current range of values
  oldrange_max: float texture, end of the current range of values
  newrange_min: float texture, start of the new range of values
  newrange_max: float texture, end of the new range of values


Parameters for plugin 'TexScalarMathBasic'
  op: integer = 0, Operation: Add(), Subtract(), Multiply(), Divide(), Minimum(), Maximum()
  input1: float texture, The first scalar input
  input2: float texture, The second scalar input
  max_displacement: float = -1, Specifies the maximum displacement value.  If the displacement value is higher than the Max Displacement value, displacement will be clipped


Parameters for plugin 'TexXSILayered'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  textures: plugin, unlimited list
  mask_textures: plugin, unlimited list
  mask_modes: integer, unlimited list, Combination of following 0:NoMask, 1:InvertMask, 2:MaskConnectionPoint,										  4:InputAlphaMask, 8:IntensityMask, 16:ThresholdMask
  blend_modes: integer, unlimited list, 0:Over, 1:In, 2:Out, 3:Plus, 4:BoundedPlus, 5:Hide-Reveal(Multiply),										  6:Hide-Reveal Bonded, 7:Difference, 8:Darken, 9:Lighten, 10:Hard Light,										  11:Soft Light, 12:Screen, 13:Overlay, 14:Blend
  alpha: float texture
  weights: float, unlimited list, Weight list
  maskthresholds: float, unlimited list, Layer threshold list


Parameters for plugin 'TexXSIBitmap'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  tile: integer = 1, 0: not tiling; 1: tile in UV; 2: tile in U; 3: tile in V
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  bitmap: plugin
  hue: float = 0, Controls a 360 degrees hue shift through HLS color space spectrum without modifying the intensity or saturation of the color.
  saturation: float = 100, Adjusts the saturation or amount of “pigment” in a color.
  gain: float = 100, Increases and decreases the contrast levels between light and dark colors. 0.5 = no change in contrast.
  brightness: float = 0, Controls the brightness of the image clip. A negative value darkens the image and a positive value brightens it.
  rgba_to_grayscl: bool = false, If true, converts the image to a gray scale (black and white) image.
  flip_u: bool = false, Flip horizontal
  flip_v: bool = false, Flip vertical
  enable_effects: bool = false, Enable effects
  exposure: float = 0, HDR exposure


Parameters for plugin 'TexXSIGradient'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  color1: acolor texture
  color2: acolor texture
  color3: acolor texture
  color4: acolor texture
  color5: acolor texture
  color6: acolor texture
  color7: acolor texture
  color8: acolor texture
  pos_color1: float = 0
  pos_color2: float = 1
  pos_color3: float = -1
  pos_color4: float = -1
  pos_color5: float = -1
  pos_color6: float = -1
  pos_color7: float = -1
  pos_color8: float = -1
  gradient_type: integer = 0, Gradient type: 0 (Vertical), 1(Horizontal), 2(Radial Wave), 3(RadialRainbow), 4(DiagonalDown), 5(DiagonalUp)
  invert_direction: bool, list of 1 elements, Inverts gradient directions if true
  clip: bool = false, If true, the gradient ends at the edge of the outermost color. Otherwise the outermost color bleeds over the untextured portion of the object
  alpha_output: bool = false, If true, copies the gradient’s alpha channel into the RGB channels, creating a grayscale image.
  alpha_factor: float texture, Determines the factor by which the Alpha is multiplied when it is copied into the RGB channels
  input: float = -1, Especially for XSI Gradient Mixer, when input type is scalar


Parameters for plugin 'TexXSIWood'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  filler_color_tex: acolor texture
  vein_color_tex: acolor texture
  vein_spread: float = 0.25
  grain_color_tex: acolor texture
  grain_bias: float = 0.5
  grain_size: float = 0.5
  grain_density: float = 0.5
  wobbly_struct: bool = true
  age: float = 50
  layer_size: float = 0.05
  randomness: float = 0.5
  center_u: float = 0.5
  center_v: float = -0.5
  ratio: float = 0.35
  complexity: float = 0.35
  u_amp: float = 0
  v_amp: float = 0
  frequency: vector = Color(0, 0, 0)
  absolute: bool = false


Parameters for plugin 'volumeXSIMulti'
  volumes: plugin, unlimited list, A list of volume plugins
  ids_list: integer, unlimited list, A list of material IDs


Parameters for plugin 'TexSurfIncidence'
  inc_mode: integer = 0, Incidence mode
  bias: float = 100, Controls the contrast between dark and light areas of shading
  gain: float = 100, Controls the brightness of the effect
  custom_vector: vector = Color(0, 0, 0), custom vector
  invert: integer = 0, Invert if enabled
  range: integer = 0, Range (0 - 0 to 90 degrees, 1 - 0 to 180 degrees)


Parameters for plugin 'TexXSIRock'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  use_3d_mapping: bool = true
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  color1_tex: acolor texture
  color2_tex: acolor texture
  grain_size: float = 0.01
  diffusion: float = 1
  mix_ratio: float = 0.5


Parameters for plugin 'xsiUVWGenEnvironment'
  uvw_matrix: matrix, Transformation of the input directions
  uvw_transform: transform, Transformation of the resulting UVW coordinates
  mapping_type: integer = 1, spherical(0), cylindrical(1), cubic strip(2), cubic cross sideways(3), cubic cross(4)


Parameters for plugin 'TexColor8Mix'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  base_color: acolor texture, Defines the base (ambient) color to use while mixing
  color1: acolor texture, Defines the compositing color. When using a texture, this parameter is used to define the image.
  mode1: integer = 0, Mix type: 0 (Mix), 1(RGB Intensity), 2(Hide/Reveal), 3(Add), 4(Add Compensate (Blend)), 5(Add Bound), 6(Lighter), 7(Darker), 8(Soft Light), 9(Hard Light), 10(Difference), 11(Hue Offset), 12(Screen)
  weight1: acolor texture, Defines the mix layer’s intensity in relation to the base color.
  alpha1: bool = false, Multiply weight by Alpha
  inuse1: bool = false, Computes this color, weight, and mixing mode.
  color2: acolor texture
  mode2: integer = 0
  weight2: acolor texture
  alpha2: bool = false
  inuse2: bool = false
  color3: acolor texture
  mode3: integer = 0
  weight3: acolor texture
  alpha3: bool = false
  inuse3: bool = false
  color4: acolor texture
  mode4: integer = 0
  weight4: acolor texture
  alpha4: bool = false
  inuse4: bool = false
  color5: acolor texture
  mode5: integer = 0
  weight5: acolor texture
  alpha5: bool = false
  inuse5: bool = false
  color6: acolor texture
  mode6: integer = 0
  weight6: acolor texture
  alpha6: bool = false
  inuse6: bool = false
  color7: acolor texture
  mode7: integer = 0
  weight7: acolor texture
  alpha7: bool = false
  inuse7: bool = false


Parameters for plugin 'TexXSICell'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  cells_color_tex: acolor texture
  background_color_tex: acolor texture


Parameters for plugin 'xsiUVWGenChannel'
  uvw_transform: transform, Initial transformation on the uvw coordinates, before mirror, crop etc
  uvw_transform_tex: transform texture
  tex_transform: transform, Final transformation on the resulting uvw coordinates, after mirror, crop etc
  nsamples: integer = 0, Number of uvw transform samples
  wrap_u: integer = 0, 0 - no wrapping, 1 - wrap, 2 - mirror tile
  wrap_v: integer = 0, 0 - no wrapping, 1 - wrap, 2 - mirror tile
  wrap_w: integer = 0, 0 - no wrapping, 1 - wrap, 2 - mirror tile
  crop_u: integer = 0, 1 to crop in the u-direction
  crop_v: integer = 0, 1 to crop in the v-direction
  crop_w: integer = 0, 1 to crop in the w-direction
  coverage: vector = Color(0, 0, 0), Coverage
  uvw_coords: output vector texture, The uvw coordinates for the specified channel at the current shading point
  wrap_mode: integer = 0, Wrap mode (0 - wrap on 0.5 boundary; 1 - wrap on integer boundary
  duvw_scale: float = 1, Additional scale factor for the texture derivatives
  uvw_channel: integer = 1
  uvwgen: plugin, Optional UVWGen from which the initial uvw coordinates will be taken, instead of the surface point
  u_alternate: integer = 0, alternate image in u direction
  v_alternate: integer = 0, alternate image in v direction


Parameters for plugin 'TexWood'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  use_3d_mapping: bool = true
  wrap: bool = true
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  filler_color_tex: acolor texture
  vein_color_tex: acolor texture
  vein_spread: float = 0.25
  layer_size: float = 0.05
  randomness: float = 0.5
  age: float = 20
  grain_color_tex: acolor texture
  grain_contr: float = 0.5
  grain_spacing: float = 0.01
  center_u: float = 0.5
  center_v: float = -0.5
  amplitude_x: float = 0
  amplitude_y: float = 0
  ratio: float = 0.35
  ripples_x: float = 1
  ripples_y: float = 1
  ripples_z: float = 1
  depth_min: float = 0
  depth_max: float = 8


Parameters for plugin 'TexWater'
  uvwgen: plugin
  height_mult: float = 1, multiplier for the height of the water
  use_3d_mapping: bool = true
  wind_direction: float = 0, direction of the wind
  wind_magnitude: float = 0, magnitude of the wind
  wind_direction_mult: float = 0
  choppy_mult: float = 0
  movement_rate: float = 1
  seed: integer = 1, Used to produce different waters
  resolution: integer = 4, Resolution -> real resolution is 2^res
  patch_size: float = 128, Size of the patch -> real resolution is 2^res


Parameters for plugin 'TexUVW'
  uvwgen: plugin, The uvw space that will be displayed as RGB
  component: integer = 0, Specifies which component to show (0 - all, 1 - u, 2 - v, 3 - w)


Parameters for plugin 'TexSwitchInt'
  nodes: plugin, unlimited list
  values: integer, unlimited list
  default: integer = 0


Parameters for plugin 'TexSwitchTransform'
  nodes: plugin, unlimited list
  textures: plugin, unlimited list
  default_texture: transform texture


Parameters for plugin 'TexSwitchMatrix'
  nodes: plugin, unlimited list
  textures: plugin, unlimited list
  default_texture: matrix texture


Parameters for plugin 'TexSwitchFloat'
  nodes: plugin, unlimited list
  textures: plugin, unlimited list
  default_texture: float texture


Parameters for plugin 'TexSwitch'
  nodes: plugin, unlimited list
  textures: plugin, unlimited list
  default_texture: acolor texture


Parameters for plugin 'TexSnow'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  use_3d_mapping: bool = true
  wrap: bool = true
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  snow_tex: acolor texture
  surface_tex: acolor texture
  threshold: float texture
  depth_decay: float texture
  thickness: float texture


Parameters for plugin 'Float3ToAColor'
  float1: float texture, First color
  float2: float texture, Second color
  float3: float texture, Third color
  alpha: float texture, Alpha
  color: output acolor texture, The resulting color
  invert: bool = false


Parameters for plugin 'TexAColorOp'
  color_a: acolor texture, The first color
  color_b: acolor texture, The second color
  mult_a: float texture, Multiplier for the first color
  mult_b: float texture, Multiplier for the second color
  result_alpha: float texture, The alpha for the result; if not specified, the resulting alpha taken from the first color)
  mode: integer = 0, Which output should be considered as the output of the main texture (0 - result_a, 1 - result_b, 2 - product, 3 - sum, 4 - difference, 5 - power, 6 - division, 7 - Minimum, 8 - Maximum, 9 - absolute difference)
  product: output acolor texture, (color_a*mult_a)*(color_b*mult_b)
  division: output acolor texture, (color_a*mult_a)/(color_b*mult_b)
  minimum: output acolor texture, Min(color_a*mult_a , color_b*mult_b)
  maximum: output acolor texture, Max(color_a*mult_a , color_b*mult_b)
  sum: output acolor texture, (color_a*mult_a)+(color_b*mult_b)
  difference: output acolor texture, (color_a*mult_a)-(color_b*mult_b)
  result_a: output acolor texture, color_a*mult_a
  result_b: output acolor texture, color_b*mult_b
  red: output float texture, (color_a*mult_a).r
  green: output float texture, (color_a*mult_a).g
  blue: output float texture, (color_a*mult_a).b
  alpha: output float texture, (color_a*mult_a).a
  intensity: output float texture, mult_a*(color_a.r+color_a.g+color_a.b)/3.0
  power: output acolor texture, (color_a*mult_a)^mult_b


Parameters for plugin 'TexFloatOp'
  float_a: float texture, The first number
  float_b: float texture, The first number
  product: output float texture, float_a*float_b
  ratio: output float texture, float_a/float_b
  sum: output float texture, float_a+float_b
  difference: output float texture, float_a-float_b
  power: output float texture, The first number raised to the power of the second number
  sin: output float texture, sin(float_a*float_b)
  cos: output float texture, cos(float_a*float_b)
  min: output float texture, min(float_a, float_b)
  max: output float texture, max(float_a, float_b)


Parameters for plugin 'TexVectorOp'
  vector_a: vector texture, The first vector
  vector_b: vector texture, The first vector
  mult_a: float texture, Multiplier for the first vector
  mult_b: float texture, Multiplier for the second vector
  dot_product: output float texture, The dot product
  cross_product: output vector texture, The cross product
  sum: output vector texture, The sum
  difference: output vector texture, The difference
  result_a: output vector texture, The first vector times the first multiplier
  result_b: output vector texture, The second vector times the second multiplier
  x: output float texture, The x-component of the first vector
  y: output float texture, The y-component of the first vector
  z: output float texture, The z-component of the first vector


Parameters for plugin 'TexSampler'
  point: output vector texture, The shading point in world space
  pointObject: output vector texture, The shading point in object space
  pointCamera: output vector texture, The shading point in camera space
  normal: output vector texture, The smooth normal in world space
  normalCamera: output vector texture, The smooth normal in camera space
  normalObject: output vector texture, The smooth normal in object space
  gnormal: output vector texture, The geometric normal in world space
  camToWorld: output transform texture, The transformation from camera to world space
  view_dir: output vector texture, The viewing direction
  frame_time: output float texture, The current frame (image) time
  ray_time: output float texture, The ray time within the motion blur interval
  facing_ratio: output float texture, The cosine of the angle between the normal and the viewing direction
  material_id: output integer texture, The surface material id, if the surface supports it
  flipped_normal: output float texture, Zero if the face is front facing and one if it is backfacing the camera
  cameraNearClipPlane: output float texture, The camera near clipping plane, calculated from the scene bounding box and the camera transform in the frame data.
  cameraFarClipPlane: output float texture, The camera far clipping plane, calculated from the scene bounding box and the camera transform in the frame data.
  uvCoord: output vector texture, The uvw coordinates of the point being shaded. These are the coordinates of channel 0.
  rayDirection: output vector texture, The viewing direction in camera space. Used for the samplerInfo node in Maya.
  pixelCenter: output vector texture, The current sample image coordinates. Used for the samplerInfo node in Maya.
  tangentUCamera: output vector texture, The U axis of the currently shaded point's UVW space, transformed in camera space. UV channel 0 is used.
  tangentVCamera: output vector texture, The V axis of the currently shaded point's UVW space, transformed in camera space. UV channel 0 is used.


Parameters for plugin 'TexRock'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  use_3d_mapping: bool = true
  wrap: bool = true
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  color1_tex: acolor texture
  color2_tex: acolor texture
  grain_size: float = 0.01
  diffusion: float = 1
  mix_ratio: float = 0.5


Parameters for plugin 'TexRemap'
  type: integer = 0, type of conversion: 0:RemapValue, 1:RemapColor, 2:RemapHSV.
  input_value: float texture
  input_color: acolor texture
  input_bias: float = 0
  input_min: float = 0
  input_max: float = 1
  output_min: float = 0
  output_max: float = 1
  float_positions: float, unlimited list, positions of the given float values
  float_values: float texture, unlimited list, the given float values
  float_types: integer, unlimited list, interpolation types for the floats
  color_positions: float, unlimited list, the given float values
  color_colors: acolor texture, unlimited list, the given colors
  color_types: integer, unlimited list, interpolation types for the colors
  red_positions: float, unlimited list, positions of the given values for the red channel
  red_values: float, unlimited list, the given values for the red channel
  red_types: integer, unlimited list, interpolation types for the red channel
  green_positions: float, unlimited list, positions of the given values for the green channel
  green_values: float, unlimited list, the given values for the green channel
  green_types: integer, unlimited list, interpolation types for the green channel
  blue_positions: float, unlimited list, positions of the given values for the blue channel
  blue_values: float, unlimited list, the given values for the blue channel
  blue_types: integer, unlimited list, interpolation types for the blue channel
  hue_positions: float, unlimited list, positions of the given values for the hue channel
  hue_values: float, unlimited list, the given values for the hue channel
  hue_types: integer, unlimited list, interpolation types for the hue channel
  saturation_positions: float, unlimited list, positions of the given values for the saturation channel
  saturation_values: float, unlimited list, the given values for the saturation channel
  saturation_types: integer, unlimited list, interpolation types for the saturation channel
  value_positions: float, unlimited list, positions of the given values for the value channel
  value_values: float, unlimited list, the given values for the value channel
  value_types: integer, unlimited list, interpolation types for the value channel
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the colors
  out_value: output float texture, the output color, depending on input_value and color params
  out_color: output acolor texture, the output value, depending on input_value/input_color and float params


Parameters for plugin 'TexRamp'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  positions: float = 0.5, positions of the given colors
  colors: acolor texture, unlimited list, the given colors
  type: integer = 0, 0:V, 1:U, 2:(U+V)/2, 3:radial, 4:circular, 5:box, 6:UV, 7:four corner, 8:tartan
  interpolation: integer = 1, 0:none, 1:linear, 2:expUp, 3:expDown, 4:smooth, 5:bump, 6:spike
  u_wave: float = 0, Sine wave offset in the u direction
  v_wave: float = 0, Sine wave offset in the v direction
  noise_amount: float = 0, Distortion noise amount
  noise_frequency: float = 0.5, Distortion noise frequency
  hue_noise_amount: float = 0, Hue noise amount
  hue_noise_frequency: float = 0.5, Hue noise frequency
  saturation_noise_amount: float = 0, Saturation noise amount
  saturation_noise_frequency: float = 0.5, Saturation noise frequency
  value_noise_amount: float = 0, Value noise amount
  value_noise_frequency: float = 0.5, Value noise frequency


Parameters for plugin 'TexPtex'
  ptex_file: string = "", The Ptex texture file
  filter_type: integer = 0, Type of filter used for the texture
  width: float = 1, width parameter used for filtering
  blur: float = 0, blur parameter used for filtering
  sharpness: float = 0, Sharpness parameter for the general bicubic filter
  lerp: bool = false, Interpolation between mipmap levels
  reverse_vertices: bool = false, Reverses the order of vertices
  r_channel: integer = 0, The index of the channel which will be used as a red channel.
  g_channel: integer = 1, The index of the channel which will be used as a green channel.
  b_channel: integer = 2, The index of the channel which will be used as a blue channel.
  a_channel: integer = -1, The index of the channel which will be used as a alpha channel.
  auto_color: bool = true, Use automatic color channel selection.
  auto_alpha: bool = true, Use automatic alpha channel selection.
  alpha_type: integer = -1, Where to take the alpha from.
  vertices: vector, unlimited list
  origFaces: integer, unlimited list
  faces: integer, unlimited list
  origFacesDegree: integer, unlimited list
  color: output acolor texture, The final texture color


Parameters for plugin 'TexNoise'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  use_3d_mapping: bool = true
  wrap: bool = true
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  persistence: float = 1, amplitude(i+1) = amplitude(i) / persistence
  amplitude_ratio: float = 1, amplitude(i+1) = amplitude(i) * amplitude_ratio
  frequency_ratio: float = 2, frequency(i+1) = frequency(i) * frequency_ratio
  frequency1: float = 1, The starting frequency
  amplitude1: float = 1, The starting amplitude
  octaves: integer = 3
  noiseType: integer = 0, 0: just noise(), 1: Perlin noise, 2: inflected Perlin noise, 3: marble (with Perlin)
  frequency_mult: float = 1
  amplitude_mult: float = 1
  inflection: integer = 0, 1: inflected, 0: not inflected
  color1: color = Color(0, 0, 0)
  color2: color = Color(1, 1, 1)
  color1_tex: acolor texture
  color2_tex: acolor texture
  color1_tex_mult: float = 1
  color2_tex_mult: float = 1
  clamp: bool = true
  dimensions: integer = 3, Two or Three dimensional noise
  time: float = 0, The time of the noise, this will act as a third or fourth dimension to the noise generating function
  threshold: float texture = 0, Value added to the noise function, noise function values above 1.0 are clamped.
  scale: acolor texture, Scale for the noise UVW coordinates.
  origin: acolor texture, Translation for the noise UVW coordinates.
  implode: float texture = 0, Amount of implode performed on the UVW coordinates.
  implode_center: acolor texture, The center of the implode effect


Parameters for plugin 'TexFloat'
  input: float texture = 0, input


Parameters for plugin 'TexMultiFloat'
  textures_list: plugin, unlimited list, A list of the sub-float-textures.
  ids_list: integer, unlimited list, A list of material/object IDs
  mode: integer = 0, The mode for the texture (0 - use face material ID, 1 - use object ID)
  default_texture: float texture = 0, The default float texture color


Parameters for plugin 'TexMulti'
  textures_list: plugin, unlimited list, A list of the sub-textures.
  ids_list: integer, unlimited list, A list of material/object IDs
  mode: integer = 0, The mode for the texture (0 - use face material ID, 1 - use object ID)
  default_texture: acolor texture = AColor(0.5, 0.5, 0.5, 1), The default texture color


Parameters for plugin 'TexTemperatureToColor'
  input: acolor texture
  temperature: float, list of 1 elements
  color: output acolor texture


Parameters for plugin 'MtlStreakFade'
  base_mtl: plugin, Base material
  fade: float = 1, 1.0f - no fade, < 1.0f - fade


Parameters for plugin 'TexVertexColorDirect'
  color_set_name: string = ""
  default_color: acolor texture = AColor(0, 0, 0, 1)


Parameters for plugin 'TexMayaConversion'
  input: float texture
  conversion_factor: float = 1
  output: output float texture


Parameters for plugin 'TexStencil'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  image: acolor texture, The texture that is used as a stencil
  mask: float texture, Represents the Stencilâ€™s transparency
  key_masking: bool = false, If true, selects the areas in the texture similar to or equal to the Color Key and masks them out
  positive_key: bool = false, If true, inverts the Chroma Key mask(only the colors specified in the Color Key and HSV Range are displayed)
  color_key: acolor texture, The color to be masked in the texture
  hue_range: float texture, The range of hues centered on the Color Key color which are also masked
  sat_range: float texture, The range of saturations centered on the Color Key color which are also masked
  val_range: float texture, The range of values centered on the Color Key color which are also masked
  default_color: acolor texture, Represents the texture that is underneath
  edge_blend: float = 0, Controls the sharpness of the texture edges.
  uvwgen: plugin, UVWGen from which the uvw coordinates will be taken


Parameters for plugin 'TexColorAndAlpha'
  color_input: acolor texture
  alpha_input: float texture


Parameters for plugin 'TexLuminance'
  input: acolor texture
  luminance: output float texture


Parameters for plugin 'TexMeshVertexColorChannel'
  channelIndex: integer = 0
  default_color: acolor texture


Parameters for plugin 'TexMeshVertexColorWithDefault'
  vertex_color: acolor texture
  default_color: acolor texture


Parameters for plugin 'TexMeshVertexColor'
  colors: color, unlimited list
  alphas: float, unlimited list
  faces: integer, unlimited list


Parameters for plugin 'TexMayaContrast'
  value: acolor texture = AColor(0, 0, 0, 1)
  contrast: acolor texture = AColor(2, 2, 2, 1)
  bias: acolor texture = AColor(0.5, 0.5, 0.5, 1)


Parameters for plugin 'TexUVWGenToTexture'
  input: plugin


Parameters for plugin 'TexCondition2'
  operation: integer = 0, 0 : Equal; 1 : Not equal; 2 : Greater than; 3 : Greater or equal; 4 : Less than; 5 : Less or equal
  first_term: float texture = 0
  second_term: float texture = 0
  color_if_true: acolor texture = AColor(0, 0, 0, 1)
  color_if_false: acolor texture = AColor(1, 1, 1, 1)


Parameters for plugin 'TransformToTex'
  input: transform texture


Parameters for plugin 'FloatToTex'
  input: float texture = 0


Parameters for plugin 'TexPlusMinusAverage'
  operation: integer = 1, 0 - No operation; 1 - Sum; 2 - Subtract from first; 3 - Average
  input1D: plugin, unlimited list
  input2D: plugin, unlimited list
  input3D: plugin, unlimited list
  output1D: output float texture
  output2D: output acolor texture
  output3D: output acolor texture


Parameters for plugin 'TexDistanceBetween'
  point1: acolor texture
  point2: acolor texture
  transform1: transform texture
  transform2: transform texture
  distance: output float texture


Parameters for plugin 'TexVectorToColor'
  input: vector texture
  color: output acolor texture


Parameters for plugin 'TexVectorProduct'
  operation: integer = 1, Operation (0 - No operation, 1 - Dot Product, 2 - Cross Product, 3 - Vector Matrix Product, 4 - Point Matrix Product)
  input1: acolor texture
  input2: acolor texture
  transform: transform texture
  normalize: bool = false, When this is true the output vector will be normalized (in case of dot product, the input vectors are normalized before the operation)
  color: output acolor texture


Parameters for plugin 'TexSetRange'
  value: acolor texture
  oldMin: acolor texture
  oldMax: acolor texture
  newMin: acolor texture
  newMax: acolor texture
  color: output acolor texture


Parameters for plugin 'TexHSVToRGB'
  inHsv: acolor texture
  color: output acolor texture


Parameters for plugin 'TexRGBToHSV'
  inRgb: acolor texture
  color: output acolor texture


Parameters for plugin 'MayaProjectionTex'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  wrap: bool = true
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  base_texture: acolor texture


Parameters for plugin 'UVWGenMayaPlace2dTexture'
  uvw_channel: integer = 1
  uvw_channel_tex: integer texture, Used when more than one mesh has UV linking specified for this 2d placement. If present will override uvw_channel.
  uvwgen: plugin, Optional UVWGen from which the initial uvw coordinates will be taken, instead of the surface point
  coverage_u: float = 1
  coverage_u_tex: float texture = 1
  coverage_v: float = 1
  coverage_v_tex: float texture = 1
  translate_frame_u: float = 0
  translate_frame_u_tex: float texture = 0
  translate_frame_v: float = 0
  translate_frame_v_tex: float texture = 0
  rotate_frame: float = 0
  rotate_frame_tex: float texture = 0
  mirror_u: bool = false
  mirror_v: bool = false
  wrap_u: bool = true
  wrap_v: bool = true
  stagger: bool = false
  repeat_u: float = 1
  repeat_u_tex: float texture = 1
  repeat_v: float = 1
  repeat_v_tex: float texture = 1
  offset_u: float = 0
  offset_u_tex: float texture = 0
  offset_v: float = 0
  offset_v_tex: float texture = 0
  rotate_uv: float = 0
  rotate_uv_tex: float texture = 0
  noise_u: float = 0
  noise_u_tex: float texture = 0
  noise_v: float = 0
  noise_v_tex: float texture = 0
  nsamples: integer = 1, The number of parameter samples to take for motion blur. 0 means the global value. 1 means motion blur should be disabled for this plugin.


Parameters for plugin 'MayaMtlMatte'
  mode: integer = 2, The matte mode (0 - black hole; 1 - solid matte; 2 - opacity gain; 3 - solid alpha)
  base_mtl: plugin, Base material
  matte_opacity: float texture, Matte opacity (0 is transparent; 1 is opaque or normal)
  alpha_transparency: float texture, Alpha transparency (used only in mode 3)


Parameters for plugin 'MayaGamma'
  input: acolor texture, The input color
  gamma: acolor texture, Gamma values
  color: output acolor texture, The resulting color


Parameters for plugin 'MayaMultiplyDivide'
  color1: acolor texture, First color
  color2: acolor texture, Second color
  operation: integer = 1, Operation (1 - multiply, 2 - divide, 3 - power)
  color: output acolor texture, The resulting color


Parameters for plugin 'TexVRayFurSampler'
  distance_along_strand: output float texture, Distance along the hair strand where the intersection occurred, in the [0,1] range.


Parameters for plugin 'TexMayaHairTransparency'


Parameters for plugin 'TexMayaHairIncandescence'


Parameters for plugin 'TexMayaHairColor'


Parameters for plugin 'TexMayaFluidTransformed'
  object_to_world: transform, list of 1 elements, The transformation from object(texture) space to world space.
  fluid_tex: plugin, The base texture. Should support the EXT_MAYA_FLUID_TEXTURE interface.
  fluid_value_scale: float = 1, Multiplier for the value taken from fluid_tex.
  noise_tex_on: bool = false, Is the built-in noise enabled ?
  noise_tex: acolor texture, The fluid's built-in noise.
  noise_gain: float texture = 0, Tells how much of the noise should be blended with the grid/gradient values.
  noise_size_x: float = 1, The X size of the fluid container.
  noise_size_y: float = 1, The Y size of the fluid container.
  noise_size_z: float = 1, The Z size of the fluid container.


Parameters for plugin 'TexMayaFluidCombined'
  tex1: plugin, The first texture. Should support the EXT_MAYA_FLUID_TEXTURE interface.
  tex2: plugin, The second texture. Should support the EXT_MAYA_FLUID_TEXTURE interface.


Parameters for plugin 'TexMayaFluidProcedural'
  type: integer = 1, 0 : constant(1.0); 1 : X gradient; 2 : Y gradient; 3 : Z gradient; 4 : center gradient; 5 : -X gradient; 6 : -Y gradient; 7 : -Z gradient; 8 : sphere; 9 : cube; 10 : cone; 11 : double cone;
  edge_fade_out: float = 0, Since the cube drop-off shape is computed a little differently, we need this here for this particular case.


Parameters for plugin 'TexMayaFluid'
  size_x: integer = 1, The number of voxels in the x dimension.
  size_y: integer = 1, The number of voxels in the y dimension.
  size_z: integer = 1, The number of voxels in the z dimension.
  values: float, unlimited list, The float grid data, an index into this is computed as follows : idx = size_x*size_y*zidx + size_x*yidx + xidx
  color_values: color, unlimited list, The color grid data, an index into this is computed as follows : idx = size_x*size_y*zidx + size_x*yidx + xidx
  interpolation_type: integer = 0, 0 : linear(8 samples, faster, but voxel borders may be visible),1 : quadratic(27 samples, slower, but voxel borders are much less likely to be visible


Parameters for plugin 'TexCompMax'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  sourceA: acolor texture, Left hand side texture.
  sourceB: acolor texture, Right hand side texture.
  operator: integer = 0, 0:Add, 1:Subtract, 2:Difference, 3:Multiply, 4:Divide, 5:Minimum, 6:Maximum


Parameters for plugin 'TexColorToFloat'
  input: float texture = 0, The color value


Parameters for plugin 'TexFloatToColor'
  input: float texture = 0, The float value


Parameters for plugin 'TexRGBMultiplyMax'
  color_a: acolor texture = AColor(1, 1, 1, 1), The first texture
  color_b: acolor texture = AColor(1, 1, 1, 1), The second texture
  alpha_mode: integer = 2, Alpha mode (0 - from color_a, 1 - from color_b, 2 - multiply


Parameters for plugin 'TexRGBTintMax'
  texture: acolor texture = AColor(1, 1, 1, 1), The texture
  red: color = Color(1, 0, 0), The red color
  green: color = Color(0, 1, 0), The green color
  blue: color = Color(0, 0, 1), The blue color


Parameters for plugin 'TexCombineColorLightMtl'
  color: color = Color(0, 0, 0), The color value
  texture: acolor texture = AColor(1, 1, 1, 1), The texture
  result_multiplier: float = 1, A multiplier for the final result


Parameters for plugin 'TexCombineColor'
  color: color = Color(0, 0, 0), The color value
  texture: acolor texture = AColor(1, 1, 1, 1), The texture
  texture_multiplier: float = 1, The texture multiplier (blends between the value and the texture)
  result_invert: bool = false, true to invert the result


Parameters for plugin 'TexCombineFloat'
  value: float = 0, The scalar value
  texture: acolor texture = AColor(0, 0, 0, 1), The texture
  texture_multiplier: float = 1, The texture multiplier (blends between the value and the texture)
  texture_clamp: bool = false, true if the texture should be clamped to 1 from above (it is always clamped to 0 from below)


Parameters for plugin 'TexBezierCurve'
  input_float: float texture, The input texture
  points: float, unlimited list, The control points; 6 floats for each point: 2D coords of the point itself, and 2D coords of the left and right tangent.
  types: integer, unlimited list, The type of the control points: 0 - free, 1 - bezier, 2- bezier smooth
  num_bezier_points: integer = 256, The number of precisely calculated points from bezier curves: default 256
  use_end_tangents: bool = true, true to extrapolate beyound the control points


Parameters for plugin 'TexNormalMapFlip'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  texmap: acolor texture = AColor(0.5, 0.5, 1, 1), The texture
  flip_red: bool = false, true to flip the texture red channel
  flip_green: bool = false, true to flip the texture green channel
  swap_redgreen: bool = false, true to swap the red and green channels


Parameters for plugin 'TexOutput'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  texmap: acolor texture = AColor(1, 1, 1, 1), The texture
  bump_amount: float = 1, Bump amount if the texture is used for bump mapping


Parameters for plugin 'UVWGenObjectBBox'
  uvw_transform: transform, Initial transformation on the uvw coordinates, before mirror, crop etc
  uvw_transform_tex: transform texture
  tex_transform: transform, Final transformation on the resulting uvw coordinates, after mirror, crop etc
  nsamples: integer = 0, Number of uvw transform samples
  wrap_u: integer = 0, 0 - no wrapping, 1 - wrap, 2 - mirror tile
  wrap_v: integer = 0, 0 - no wrapping, 1 - wrap, 2 - mirror tile
  wrap_w: integer = 0, 0 - no wrapping, 1 - wrap, 2 - mirror tile
  crop_u: integer = 0, 1 to crop in the u-direction
  crop_v: integer = 0, 1 to crop in the v-direction
  crop_w: integer = 0, 1 to crop in the w-direction
  coverage: vector = Color(0, 0, 0), Coverage
  uvw_coords: output vector texture, The uvw coordinates for the specified channel at the current shading point
  wrap_mode: integer = 0, Wrap mode (0 - wrap on 0.5 boundary; 1 - wrap on integer boundary
  duvw_scale: float = 1, Additional scale factor for the texture derivatives


Parameters for plugin 'MtlObjBBox'
  base_mtl: plugin, Base material
  bbox_min: vector = Color(0, 0, 0), Min. coordinates for object bounding box
  bbox_max: vector = Color(0, 0, 0), Max. coordinates for object bounding box


Parameters for plugin 'TexGradient'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  color1: acolor texture = AColor(0, 0, 0, 1), First color
  color2: acolor texture = AColor(0.5, 0.5, 0.5, 1), Middle color
  color3: acolor texture = AColor(1, 1, 1, 1), End color
  has_textures: bool = false, This affects bump mapping, following a peculiarity in the 3ds Max implementation
  middle: float = 0.5, Middle color position
  type: integer = 0, Gradient type (0 - linear, 1 - radial)
  noise_amount: float = 0, Noise amount
  noise_size: float = 1, Noise size
  noise_type: integer = 0, Noise type (0 - regular, 1 - fractal, 2 - turbulence)
  noise_iterations: float = 4, Noise iterations
  noise_phase: float = 0, Noise phase
  noise_low: float = 0, Noise low threshold
  noise_high: float = 1, Noise high threshold
  noise_smooth: float = 0, Threshold smoothing


Parameters for plugin 'TexFalloff'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  color1: acolor texture = AColor(1, 1, 1, 1), First color
  color2: acolor texture = AColor(0, 0, 0, 0), Second color
  type: integer = 0, Type (0 - towards/away, 1 - perpendicular/parallel, 2 - Fresnel, 3 - shadow/light, 4 - distance blend)
  direction_type: integer = 0, Direction type (0 - viewZ, 1 - viewX, 2 - viewY, 3 - explicit, 4 - localX, 5 - localY, 6 - localZ, 7 - worldX, 8 - worldY, 9 - worldZ)
  fresnel_ior: float = 1.6, IOR for the Fresnel falloff type
  dist_extrapolate: bool = false, Extrapolate for the distance blend falloff type
  dist_near: float = 0, Near distance for the distance blend falloff type
  dist_far: float = 100, Far distance for the distance blend falloff type
  explicit_dir: vector = Color(0, 0, 0), Direction for the explicit direction type
  blend_output: output float texture, The blending amount, based on the parameters
  use_blend_input: bool = false
  blend_input: float texture = 0.5, If specified and use_blend_input is true, the final blending amount will be taken from this texture


Parameters for plugin 'TexNoiseMax'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  use_3d_mapping: bool = true
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  color1: acolor texture = AColor(1, 1, 1, 1), First color
  color2: acolor texture = AColor(0, 0, 0, 0), Second color
  size: float = 1, Size
  phase: float = 0, Phase
  iterations: float = 3, Number of iterations for the fractal generator
  low: float = 0, Low threshold
  high: float = 1, High threshold
  type: integer = 0, Type (0 - regular, 1 - fractal, 3 - turbulence)


Parameters for plugin 'TexMaskMax'
  texture: acolor texture = AColor(1, 1, 1, 1), The base texture
  mask: acolor texture = AColor(1, 1, 1, 1), The mask texture
  invert_mask: bool = false, true to invert the mask


Parameters for plugin 'TexMix'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  color1: acolor texture = AColor(1, 1, 1, 1), First color
  color2: acolor texture = AColor(0, 0, 0, 0), Second color
  mix_map: acolor texture = AColor(0.5, 0.5, 0.5, 1), Mix amount texture
  mix_amount: float = 0, Mix amount
  transition_upper: float = 0.7, Transition zone - upper
  transition_lower: float = 0.3, Transition zone - lower
  use_curve: integer = 0, If true the blend curve is used


Parameters for plugin 'TexMarbleMax'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  use_3d_mapping: bool = true
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  color1: acolor texture = AColor(1, 1, 1, 1), First color
  color2: acolor texture = AColor(0, 0, 0, 0), Second color
  size: float = 70, Size
  vein_width: float = 0.02, Vein width


Parameters for plugin 'TexSwirl'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  color1: acolor texture = AColor(1, 1, 1, 1), First color
  color2: acolor texture = AColor(0, 0, 0, 0), Second color
  swirl_intensity: float = 2, Swirl Intensity
  color_contrast: float = 0.4, Color Contrast
  swirl_amount: float = 1, Swirl Amount
  constant_detail: integer = 4, Constant Detail
  center_x: float = -0.5, Center Position X
  center_y: float = -0.5, Center Position Y
  random_seed: float = 0, Random Seed
  twist: float = 1, Twist


Parameters for plugin 'TexTiles'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  color_mortar: acolor texture = AColor(0.7, 0.7, 0.7, 1), Mortar color
  color_tiles: acolor texture = AColor(0.6, 0.5, 0.4, 1), Tiles color
  horizontal_count: float = 1, Tiles horizontal count
  vertical_count: float = 1, Tiles vertical count
  color_variance: float = 0, Color variance
  horizontal_gap: float = 0, Horizontal gap between tiles
  vertical_gap: float = 0, Vertical gap between tiles
  pattern_type: integer = 0, Tiles pattern: 0-Custom Tiles, 1-Running Bond, 2-Common Flemish Bond, 3-English Bond, 4-1/2 Running Bond, 5-Stack Bond, 6-Fine Running Bond, 7-Fine Stack Bond
  line_shift: float = 0.5, Line shift
  random_shift: float = 0, Random shift
  edge_roughness: float = 0, Edge roughness
  holes: integer = 0, Holes
  random_seed: integer = 0, Random seed
  fade_variance: float = 0, Fade variance
  row_modify: integer = 0, if 1 - custom row parameters
  column_modify: integer = 0, if 1 - custom column parameters
  per_row: integer = 1, every per_row row is modified by corresponding change value
  row_change: float = 1, row change value modifying the number of tiles in affected rows
  per_column: integer = 1, every per_column column is modified by corresponding change value
  column_change: float = 1, column change value modifying the number of tiles in affected columns


Parameters for plugin 'TexSpeckle'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  use_3d_mapping: bool = true
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  color1: acolor texture = AColor(1, 1, 1, 1), First color
  color2: acolor texture = AColor(0, 0, 0, 0), Second color
  size: float = 1, Size


Parameters for plugin 'TexSmoke'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  use_3d_mapping: bool = true
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  color1: acolor texture = AColor(1, 1, 1, 1), First color
  color2: acolor texture = AColor(0, 0, 0, 0), Second color
  size: float = 1, Size
  iterations: integer = 5, Iterations
  phase: float = 0, Phase
  exponent: float = 1.5, Exponent


Parameters for plugin 'TexStucco'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  use_3d_mapping: bool = true
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  color1: acolor texture = AColor(1, 1, 1, 1), First color
  color2: acolor texture = AColor(0, 0, 0, 0), Second color
  size: float = 1, Size
  thickness: float = 4, Thickness
  threshold: float = 0.2, Threshold


Parameters for plugin 'TexSplat'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  use_3d_mapping: bool = true
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  color1: acolor texture = AColor(1, 1, 1, 1), First color
  color2: acolor texture = AColor(0, 0, 0, 0), Second color
  size: float = 1, Size
  iterations: integer = 4, Number of iterations for the fractal generator
  threshold: float = 0.2, Threshold
  smoothing: float = 0.02, Transition smoothing


Parameters for plugin 'TexLayeredMax'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  textures: plugin, unlimited list
  masks: plugin, unlimited list
  blend_modes: integer, unlimited list, 0:None, 1:Over, 2:In, 3:Out, 4:Add, 5:Subtract, 6:Multiply, 7:Difference, 8:Lighten, 9:Darken, 10:Saturate, 11:Desaturate, 12:Illuminate
  opacities: float, unlimited list, The opacity of each texture
  alpha: float texture


Parameters for plugin 'TexGradRamp'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  positions: float = 0.5, positions of the given colors
  colors: acolor texture, unlimited list, the given colors
  texture_map: acolor texture, the texture used for mapped gradient ramp
  gradient_type: integer = 0, 0:four corner, 1:box, 2:diagonal, 3:lighting, 4:linear, 5:mapped, 6:normal, 7:pong, 8:radial, 9:spiral, 10:sweep, 11:tartan
  interpolation: integer = 1, 0:none, 1:linear, 2:expUp, 3:expDown, 4:smooth, 5:bump, 6:spike
  noise_amount: float = 0, Distortion noise amount
  noise_type: integer = 0, 0:regular, 1:fractal, 2:turbulence
  noise_size: float = 1, default = 1.0
  noise_phase: float = 0, default = 0.0
  noise_levels: float = 4, default = 4.0
  noise_treshold_low: float = 0, default = 0.0f
  noise_treshold_high: float = 0, default = 1.0f
  noise_smooth: float = 0, default = 0.0f


Parameters for plugin 'ColorCorrect'
  source_color: acolor = AColor(0, 0, 0, 0), Source color
  texture_map: acolor texture, The texture being color corrected
  preprocess: bool = false, true to enable preprocessing
  pre_brightness: float = 0, Added to the texture brightness
  pre_contrast: float = 1, Contrast
  pre_gamma: float = 1, Gamma
  pre_mono: bool = false, true to convert to grayscale
  pre_invert: bool = false, true to invert the input color
  pre_unmult_alpha: bool = false, true to unmultiply alpha
  pre_clamp: bool = false, true to clamp the input color
  pre_clamp_min: float = 0, low clamp value
  pre_clamp_max: float = 1, high clamp value
  pre_clamp_normalize: bool = false, true to normalize the clamped input to 0.0-1.0
  hsl_on: bool = false
  hsl_hue_offset: float = 0
  hsl_hue_gain: float texture = 0
  hsl_saturation_offset: float texture = 0
  hsl_saturation_gain: float texture = 1
  hsl_lightness_offset: float texture = 0
  hsl_lightness_gain: float texture = 1
  hsv_on: bool = false
  hsv_hue_offset: float = 0
  hsv_hue_gain: float texture = 0
  hsv_saturation_offset: float texture = 0
  hsv_saturation_gain: float texture = 1
  hsv_value_offset: float texture = 0
  hsv_value_gain: float texture = 1
  rgba_on: bool = false
  red_channel: integer = 0, 0-red, 1-green, 2-blue, 3-alpha, 4-intensity, 5-in_red, 6-in_green, 7-in_blue, 8-in_alpha, 9-in_intensity, 10-hsl_hue, 11-hsl_saturation, 12-hsl_lightness, 13-hsv_hue, 14-hsv_saturation, 15-hsv_value
  red_offset: float texture = 0
  red_gain: float texture = 1
  green_channel: integer = 0, 0-red, 1-green, 2-blue, 3-alpha, 4-intensity, 5-in_red, 6-in_green, 7-in_blue, 8-in_alpha, 9-in_intensity, 10-hsl_hue, 11-hsl_saturation, 12-hsl_lightness, 13-hsv_hue, 14-hsv_saturation, 15-hsv_value
  green_offset: float texture = 0
  green_gain: float texture = 1
  blue_channel: integer = 0, 0-red, 1-green, 2-blue, 3-alpha, 4-intensity, 5-in_red, 6-in_green, 7-in_blue, 8-in_alpha, 9-in_intensity, 10-hsl_hue, 11-hsl_saturation, 12-hsl_lightness, 13-hsv_hue, 14-hsv_saturation, 15-hsv_value
  blue_offset: float texture = 0
  blue_gain: float texture = 1
  alpha_channel: integer = 0, 0-red, 1-green, 2-blue, 3-alpha, 4-intensity, 5-in_red, 6-in_green, 7-in_blue, 8-in_alpha, 9-in_intensity, 10-hsl_hue, 11-hsl_saturation, 12-hsl_lightness, 13-hsv_hue, 14-hsv_saturation, 15-hsv_value
  alpha_offset: float texture = 0
  alpha_gain: float texture = 1
  premultiply_new_alpha: bool = false
  postprocess: bool = false
  post_mono: bool = false
  post_invert: bool = false
  post_clamp: bool = false
  post_clamp_min: float = 0
  post_clamp_max: float = 1
  post_clamp_normalize: bool = false


Parameters for plugin 'ColorTextureToMono'
  value: float = 0
  color_texture: acolor texture = AColor(0, 0, 0, 0)


Parameters for plugin 'ColorCorrection'
  source_color: acolor = AColor(0, 0, 0, 0), Source color
  texture_map: acolor texture, The texture being color corrected
  rewire_red: integer = 0, 0-red, 1-green, 2-blue, 3-alpha, 4-redinv, 5-greeninv, 6-blueinv, 7-alphainv, 8-monochrome, 9-One, 10-Zero
  rewire_green: integer = 1, 0-red, 1-green, 2-blue, 3-alpha, 4-redinv, 5-greeninv, 6-blueinv, 7-alphainv, 8-monochrome, 9-One, 10-Zero
  rewire_blue: integer = 2, 0-red, 1-green, 2-blue, 3-alpha, 4-redinv, 5-greeninv, 6-blueinv, 7-alphainv, 8-monochrome, 9-One, 10-Zero
  rewire_alpha: integer = 3, 0-red, 1-green, 2-blue, 3-alpha, 4-redinv, 5-greeninv, 6-blueinv, 7-alphainv, 8-monochrome, 9-One, 10-Zero
  hue_shift: float = 0, added to the color hue
  saturation: float = 0, added to the color saturation
  hue_tint: acolor = AColor(0, 0, 0, 0), Hue tint
  tint_strength: float = 0, default = 0
  brightness: float = 0, default = 0.0 - value is added to the texture brightness
  contrast: float = 1, default = 1.0f
  lightness_mode: integer = 0, Lightness mode (0 - standard, 1 - advanced)
  adv_brightness: float = 1, Color multiplier
  adv_contrast: float = 1, Color contrast
  adv_base: float = 1, Contrast base
  adv_offset: float = 0, Color offset
  adv_use_red: bool = false, true to use the red component ov the adv_rgb_* parameters
  adv_use_green: bool = false, true to use the green component ov the adv_rgb_* parameters
  adv_use_blue: bool = false, true to use the blue component ov the adv_rgb_* parameters
  adv_rgb_brightness: color = Color(1, 1, 1), Color multiplier rgb
  adv_rgb_contrast: color = Color(1, 1, 1), Color contrast rgb
  adv_rgb_base: color = Color(1, 1, 1), Contrast base rgb
  adv_rgb_offset: color = Color(0, 0, 0), Color offset rgb


Parameters for plugin 'LightAmbientMax'
  enabled: bool = true, true if the light is enabled
  mode: integer = 0, light mode
  gi_min_distance: float = 0, minimal distance for gi rays
  color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The ambient color
  compensate_exposure: bool = true, true to compensate for camera exposure


Parameters for plugin 'LightDirectMax'
  enabled: bool = true, true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
  transform: transform
  color: color = Color(1, 1, 1), Color of the light
  color_tex: acolor texture, A color texture that if present will override the color parameter
  shadows: bool = true, true if the light casts shadows and false otherwise
  shadowColor: color = Color(0, 0, 0), The shadow color. Anything but black is not physically accurate.
  shadowColor_tex: acolor texture, A color texture that if present will override the shadowColor parameter
  shadowBias: float = 0, Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
  photonSubdivs: integer = 500
  causticSubdivs: integer = 1000
  diffuseMult: float = 1, Multiplier for the diffuse photons.
  causticMult: float = 1, Multiplier for the caustic photons.
  cutoffThreshold: float = 0.001, Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
  affectDiffuse: bool = true, true if the light produces diffuse lighting and false otherwise
  affectSpecular: bool = true, true if the light produces specular hilights and false otherwise
  bumped_below_surface_check: bool = false, true if the bumped normal should be used to check if the light dir is below the surface
  nsamples: integer = 0, Number of parameter samples for motion blur.
  diffuse_contribution: float = 1, Diffuse contribution for the light
  specular_contribution: float = 1, Specular contribution for the light
  channels: plugin, unlimited list, Render channels the result of this light will be written to
  channels_raw: plugin, unlimited list, Render channels the raw diffuse result of this light will be written to
  channels_diffuse: plugin, unlimited list, Render channels the diffuse result of this light will be written to
  channels_specular: plugin, unlimited list, Render channels the specular result of this light will be written to
  use_global_light_level: bool = true, true if the light should use the global light level setting
  units: integer = 0, Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
  intensity: float = 1, Light intensity
  intensity_tex: float texture, A float texture that if present will override the intensity parameter
  shadowRadius: float = 0, The size of the light; 0.0 is a point light, larger values produces soft (area) shadows
  areaSpeculars: bool = false, If true, the hilights will match the shape of the light; if false, hilights will always be calculated as from a point light
  shadowSubdivs: integer = 8
  projector_map: acolor texture
  decay_type: integer = 0, Decay type (0 - no decay, 1 - linear, 2 - square)
  decay_start: float = 1
  near_attenuation: bool = false, true to use near attenuation
  near_attenuation_start: float = 0, Near attenuation start
  near_attenuation_end: float = 0, Near attenuation end
  far_attenuation: bool = false, true to use far attenuation
  far_attenuation_start: float = 0, far attenuation start
  far_attenuation_end: float = 0, far attenuation end
  shadowShape: integer = 0, Shape for soft shadows (0 - box, 1 - sphere)
  shadowRadius1: float = 0, V-size for box shadows
  shadowRadius2: float = 0, W-size for box shadows
  fallsize: float = 1, The entire spot cone, in radians
  hotspot: float = 0, The hotspot
  shape_type: integer = 0, The shape of the beam (0 - circular, 1 - rectangular)
  rect_aspect: float = 1, Aspect for the rectangle shape
  overshoot: bool = false, true if the light is not limited in the beam


Parameters for plugin 'LightSpotMax'
  enabled: bool = true, true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
  transform: transform
  color: color = Color(1, 1, 1), Color of the light
  color_tex: acolor texture, A color texture that if present will override the color parameter
  shadows: bool = true, true if the light casts shadows and false otherwise
  shadowColor: color = Color(0, 0, 0), The shadow color. Anything but black is not physically accurate.
  shadowColor_tex: acolor texture, A color texture that if present will override the shadowColor parameter
  shadowBias: float = 0, Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
  photonSubdivs: integer = 500
  causticSubdivs: integer = 1000
  diffuseMult: float = 1, Multiplier for the diffuse photons.
  causticMult: float = 1, Multiplier for the caustic photons.
  cutoffThreshold: float = 0.001, Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
  affectDiffuse: bool = true, true if the light produces diffuse lighting and false otherwise
  affectSpecular: bool = true, true if the light produces specular hilights and false otherwise
  bumped_below_surface_check: bool = false, true if the bumped normal should be used to check if the light dir is below the surface
  nsamples: integer = 0, Number of parameter samples for motion blur.
  diffuse_contribution: float = 1, Diffuse contribution for the light
  specular_contribution: float = 1, Specular contribution for the light
  channels: plugin, unlimited list, Render channels the result of this light will be written to
  channels_raw: plugin, unlimited list, Render channels the raw diffuse result of this light will be written to
  channels_diffuse: plugin, unlimited list, Render channels the diffuse result of this light will be written to
  channels_specular: plugin, unlimited list, Render channels the specular result of this light will be written to
  use_global_light_level: bool = true, true if the light should use the global light level setting
  units: integer = 0, Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
  intensity: float = 1, Light intensity
  intensity_tex: float texture, A float texture that if present will override the intensity parameter
  shadowRadius: float = 0, The size of the light; 0.0 is a point light, larger values produces soft (area) shadows
  areaSpeculars: bool = false, If true, the hilights will match the shape of the light; if false, hilights will always be calculated as from a point light
  shadowSubdivs: integer = 8
  projector_map: acolor texture
  decay_type: integer = 0, Decay type (0 - no decay, 1 - linear, 2 - square)
  decay_start: float = 1
  near_attenuation: bool = false, true to use near attenuation
  near_attenuation_start: float = 0, Near attenuation start
  near_attenuation_end: float = 0, Near attenuation end
  far_attenuation: bool = false, true to use far attenuation
  far_attenuation_start: float = 0, far attenuation start
  far_attenuation_end: float = 0, far attenuation end
  shadowShape: integer = 0, Shape for soft shadows (0 - box, 1 - sphere)
  shadowRadius1: float = 0, V-size for box shadows
  shadowRadius2: float = 0, W-size for box shadows
  fallsize: float = 1, The entire spot cone, in radians
  hotspot: float = 0, The hotspot
  shape_type: integer = 0, The shape of the beam (0 - circular, 1 - rectangular)
  rect_aspect: float = 1, Aspect for the rectangle shape
  overshoot: bool = false, true if the light is not limited in the beam


Parameters for plugin 'LightOmniMax'
  enabled: bool = true, true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
  transform: transform
  color: color = Color(1, 1, 1), Color of the light
  color_tex: acolor texture, A color texture that if present will override the color parameter
  shadows: bool = true, true if the light casts shadows and false otherwise
  shadowColor: color = Color(0, 0, 0), The shadow color. Anything but black is not physically accurate.
  shadowColor_tex: acolor texture, A color texture that if present will override the shadowColor parameter
  shadowBias: float = 0, Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
  photonSubdivs: integer = 500
  causticSubdivs: integer = 1000
  diffuseMult: float = 1, Multiplier for the diffuse photons.
  causticMult: float = 1, Multiplier for the caustic photons.
  cutoffThreshold: float = 0.001, Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
  affectDiffuse: bool = true, true if the light produces diffuse lighting and false otherwise
  affectSpecular: bool = true, true if the light produces specular hilights and false otherwise
  bumped_below_surface_check: bool = false, true if the bumped normal should be used to check if the light dir is below the surface
  nsamples: integer = 0, Number of parameter samples for motion blur.
  diffuse_contribution: float = 1, Diffuse contribution for the light
  specular_contribution: float = 1, Specular contribution for the light
  channels: plugin, unlimited list, Render channels the result of this light will be written to
  channels_raw: plugin, unlimited list, Render channels the raw diffuse result of this light will be written to
  channels_diffuse: plugin, unlimited list, Render channels the diffuse result of this light will be written to
  channels_specular: plugin, unlimited list, Render channels the specular result of this light will be written to
  use_global_light_level: bool = true, true if the light should use the global light level setting
  units: integer = 0, Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
  intensity: float = 1, Light intensity
  intensity_tex: float texture, A float texture that if present will override the intensity parameter
  shadowRadius: float = 0, The size of the light; 0.0 is a point light, larger values produces soft (area) shadows
  areaSpeculars: bool = false, If true, the hilights will match the shape of the light; if false, hilights will always be calculated as from a point light
  shadowSubdivs: integer = 8
  projector_map: acolor texture
  decay_type: integer = 0, Decay type (0 - no decay, 1 - linear, 2 - square)
  decay_start: float = 1
  near_attenuation: bool = false, true to use near attenuation
  near_attenuation_start: float = 0, Near attenuation start
  near_attenuation_end: float = 0, Near attenuation end
  far_attenuation: bool = false, true to use far attenuation
  far_attenuation_start: float = 0, far attenuation start
  far_attenuation_end: float = 0, far attenuation end
  shadowShape: integer = 0, Shape for soft shadows (0 - box, 1 - sphere)
  shadowRadius1: float = 0, V-size for box shadows
  shadowRadius2: float = 0, W-size for box shadows


Parameters for plugin 'TexMarble'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  use_3d_mapping: bool = true
  wrap: bool = true
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  filler_color_tex: acolor texture
  vein_color_tex: acolor texture
  vein_width: float texture
  diffusion: float texture
  contrast: float texture
  amplitude: float texture
  ratio: float texture
  ripples: acolor texture
  depth_min: float texture
  depth_max: float texture


Parameters for plugin 'TexLeather'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  wrap: bool = true
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  cell_color_tex: acolor texture
  crease_color_tex: acolor texture
  cell_color: color = Color(1, 1, 1)
  crease_color: color = Color(0, 0, 0)
  cell_color_tex_mult: float = 1
  crease_color_tex_mult: float = 1
  size: float = 0.5
  density: float = 1
  spottyness: float = 0.1
  randomness: float = 0.5
  threshold: float = 0.83
  creases: bool = true


Parameters for plugin 'TexLayered'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  textures: plugin, unlimited list
  blend_modes: integer, unlimited list, 0:None, 1:Over, 2:In, 3:Out, 4:Add, 5:Subtract, 6:Multiply, 7:Difference, 8:Lighten, 9:Darken, 10:Saturate, 11:Desaturate, 12:Illuminate
  alpha: float texture


Parameters for plugin 'TexInvert'
  texture: acolor texture, The texture to be inverted
  invert_alpha: bool = false
  color: output acolor texture, The inverted texture color


Parameters for plugin 'TexGrid'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  line_color: acolor texture
  fill_color: acolor texture
  u_width: float = 0.1
  v_width: float = 0.1


Parameters for plugin 'TexGranite'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  use_3d_mapping: bool = true
  wrap: bool = true
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  color1_tex: acolor texture
  color2_tex: acolor texture
  color3_tex: acolor texture
  filler_color_tex: acolor texture
  cell_size: float = 0.15
  density: float = 1
  mix_ratio: float = 0.5
  spottyness: float = 0.3
  randomness: float = 1
  threshold: float = 0.5
  creases: bool = true


Parameters for plugin 'TexFresnel'
  fresnel_ior: float = 1.55, Fresnel ior.
  refract_ior: float = 1.55, Refraction ior of the underlying surface; this is ignored if the surface has a volume shader (the volume IOR is used).
  white_color: acolor texture, Refraction (front) color
  black_color: acolor texture, Reflection (side) color


Parameters for plugin 'TexDirt'
  white_color: acolor texture
  black_color: acolor texture
  radius: float texture = 10
  distribution: float = 0
  falloff: float = 0
  subdivs: integer = 8
  bias_x: float = 0
  bias_y: float = 0
  bias_z: float = 0
  ignore_for_gi: bool = true
  consider_same_object_only: bool = false
  invert_normal: bool = false
  double_sided: bool = false, if true, the occlusion on both sides of the surface will be calculated
  work_with_transparency: bool = false
  ignore_self_occlusion: bool = false
  render_nodes: plugin, unlimited list
  affect_result_nodes: plugin, unlimited list
  affect_result_nodes_inclusive: bool = false, if true the affect_result_nodes list is inclusive
  mode: integer = 0, Mode (0 - ambient occlusion; 1 - Phong reflection occlusion; 2 - Blinn reflection occlusion; 3 - Ward reflection occlusion)
  environment_occlusion: bool = false, true to compute the environment for unoccluded samples
  affect_reflection_elements: bool = false, true to add the occlusion to relection render elements when mode>0
  glossiness: float texture, A texture for the glossiness when mode>0


Parameters for plugin 'TexCustomBitmap'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  tile: integer = 1, 0: not tiling; 1: tile in UV; 2: tile in U; 3: tile in V
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase


Parameters for plugin 'TexCloth'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  gap_color: acolor texture
  u_color: acolor texture
  v_color: acolor texture
  u_width: float texture
  v_width: float texture
  u_wave: float texture
  v_wave: float texture
  randomness: float texture
  width_spread: float texture
  bright_spread: float texture


Parameters for plugin 'TexCondition'
  operation: integer texture, The condition check: 0 - equal, 1 - not equal, 2 - greater than, 3 - greater or equal, 4 - less than, 5 - less or equal
  op_a: float texture, The first number to compare
  op_b: float texture, The second number to compare
  result_true: acolor texture, The color to return if the condition is true
  result_false: acolor texture, The color to return if the condition is false
  color: output acolor texture, The resulting color


Parameters for plugin 'TexClamp'
  texture: acolor texture
  min_color: acolor texture
  max_color: acolor texture


Parameters for plugin 'TexChecker'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  white_color: acolor texture = AColor(1, 1, 1, 1), The white checker color
  black_color: acolor texture = AColor(0, 0, 0, 0), The black checker color
  contrast: float texture = 1, Contrast value


Parameters for plugin 'TexCellular'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  use_3d_mapping: bool = true
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  center_color: acolor texture
  edge_color: acolor texture
  bg_color: acolor texture
  size: float = 0.2
  spread: float = 0.5
  density: float = 0.25
  type: integer = 0, 0 = dots; 1 = chips; 2 = cells; 3 = chess cells; 4 = plasma
  low: float = 0, Low threshold (for the bg color)
  middle: float = 0.5, Middle threshold (for the edge color)
  high: float = 1, High threshold (for the center color)
  fractal: bool = false
  fractal_iterations: float = 3, The number of fractal iterations
  fractal_roughness: float = 0, The fractal roughness (0.0f is very rough; 1.0 is smooth - i.e. no fractal)
  components: output vector texture, Outputs (F(1), F(2), F(3)) (the distances to the three closest points in the cellular context) as a Vector


Parameters for plugin 'TexBulge'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  u_width: float = 0.1
  v_width: float = 0.1


Parameters for plugin 'TexBlendBumpNormal'
  normalMap1: acolor texture, First tangent space normal map.
  normalMapWeight1: float texture = 1, Weight of first tangent space normal map.
  normalMap2: acolor texture, Second tangent space normal map.
  normalMapWeight2: float texture = 1, Weight of second tangent space normal map.
  bumpMap1: acolor texture, First bump map.
  bumpMapWeight1: float texture = 1, Weight of first bump map.
  bumpMap2: acolor texture, Second bump map.
  bumpMapWeight2: float texture = 1, Weight of second bump map.
  sharpen: bool = true


Parameters for plugin 'TexBlend'
  color_a: acolor texture
  color_b: acolor texture
  blend_amount: float texture
  composite: bool = false, If true, color_b will be composited over color_a with the given weight, taking its alpha into account


Parameters for plugin 'TexBitmap'
  compatibility_with: integer = 0, This is used to differentiate between textures exported from different applications. The value means : 0 - 3ds Max (this is also the default), 1 - Maya, ...
  alpha_from_intensity: bool = false, If true, the resulting alpha is the color intensity; otherwise the alpha is taken from the bitmap alpha
  invert: bool = false, If true, the resulting texture color will be inverted
  invert_alpha: bool = true, If true and invert is on, the resulting texture alpha will be inverted too. If false, just the color will be inverted
  color_mult: acolor texture = AColor(1, 1, 1, 1), A multiplier for the texture color
  color_offset: acolor texture = AColor(0, 0, 0, 0), An additional offset for the texture color
  alpha_mult: float texture = 1, A multiplier for the texture alpha
  alpha_offset: float texture = 0, An additional offset for the texture alpha
  nouvw_color: acolor texture = AColor(0.5, 0.5, 0.5, 1), The color when there are no valid uvw coordinates
  color: output acolor texture, The resulting color
  out_transparency: output acolor texture, The resulting transparency
  out_alpha: output float texture, The resulting alpha
  out_intensity: output float texture, The resulting intensity
  tile: integer = 1, 0: not tiling; 1: tile in UV; 2: tile in U; 3: tile in V
  uvwgen: plugin, The uvw generator for the texture
  placement_type: integer = 0, The way the valid portion of the texture is applied: 0 - the whole texture is valid, 1 - crop, 2 -place
  u: float = 0, U coordinate of the valid texture sector
  v: float = 0, V coordinate of the valid texture sector
  w: float = 1, Width of the valid texture sector
  h: float = 1, Height of the valid texture sector
  jitter: float = 0, Amount of random placement variation
  tile_u: integer = 0, If true there is horizontal tiling
  tile_v: integer = 0, If true there is vertical tiling
  uv_noise_on: integer = 0, If true the noise is enabled
  uv_noise_animate: integer = 0, If true the noise is animated
  uv_noise_amount: float = 1, UV noise amount
  uv_noise_levels: float = 1, UV noise iterations
  uv_noise_size: float = 1, UV noise size
  un_noise_phase: float = 0, UV noise phase
  bitmap: plugin


Parameters for plugin 'TexAColor'
  uvwgen: plugin
  texture: acolor texture


Parameters for plugin 'SphericalHarmonicsRenderer'
  file_name: string = "C:\temp"
  precalc_light_per_frame: integer = 1
  sample_environment: integer = 1
  is_hemispherical: integer = 1
  subdivs: integer = 30
  apply_filtering: integer = 0
  filter_strength: float = 0.5


Parameters for plugin 'SphericalHarmonicsExporter'
  mode: integer = 0
  bands: integer = 4
  subdivs: integer = 50
  bounces: integer = 1
  ray_bias: float = 0.001
  file_name: string = "C:\temp"
  file_format: integer = 0
  per_normal: bool = false
  hit_recording: bool = false
  object_space: bool = false
  node: plugin, Node of the mesh


Parameters for plugin 'SettingsUnitsInfo'
  meters_scale: float = 1, The number by which a 3d distance must be multiplied to covert it into meters.
  photometric_scale: float = 0.001, The number by which the power of photometric lights should be scaled when rendering.
  scene_upDir: vector = Color(0, 0, 0), The 'up' direction for the scene.


Parameters for plugin 'SettingsRenderChannels'
  unfiltered_fragment_method: integer = 0, Determines which fragment to use for unfiltered render elements (0 - best coverage; 1 - closest to camera).


Parameters for plugin 'SettingsRegionsGenerator'
  xc: integer = 48, Max. width
  yc: integer = 48, Max. height
  xymeans: integer = 0, Size in pixels or number of regions
  seqtype: integer = 4, Sequence type
  reverse: bool = false


Parameters for plugin 'SettingsRaycaster'
  maxLevels: integer = 60, Max. tree depth
  minLeafSize: float = 0, Min. voxel size
  faceLevelCoef: float = 2, Balance coefficient between depth and faces per voxel
  dynMemLimit: integer = 500, Limit for dynamic geometry, in megabytes
  optLevel: integer = 0, Optimization level (must be 0)


Parameters for plugin 'SettingsDMCSampler'
  time_dependent: bool = false
  adaptive_amount: float = 0.85
  adaptive_threshold: float = 0.005
  adaptive_min_samples: integer = 8
  subdivs_mult: float = 1
  path_sampler_type: integer = 2


Parameters for plugin 'SettingsDMCGI'
  subdivs: integer = 8
  depth: integer = 3


Parameters for plugin 'SettingsPhotonMap'
  bounces: integer = 10
  max_photons: integer = 30
  prefilter: bool = false
  prefilter_samples: integer = 10
  mode: integer = 0
  file: string = ""
  auto_search_distance: bool = true
  search_distance: float = 1e+18
  convex_hull_estimate: bool = false
  dont_delete: bool = true
  auto_save: bool = false
  auto_save_file: string = ""
  store_direct_light: bool = true
  multiplier: float = 1
  max_density: float = 0
  retrace_corners: float = 0
  retrace_bounces: integer = 10
  show_calc_phase: bool = false


Parameters for plugin 'SettingsTGA'
  compression: integer = 2, Compression type for TGA output


Parameters for plugin 'SettingsSGI'
  bits_per_channel: integer = 8, Bits per channel (8 or 16)


Parameters for plugin 'SettingsTIFF'
  bits_per_channel: integer = 32, Bits per channel (8, 16 bit fixed or 32-bit floating point)


Parameters for plugin 'SettingsJPEG'
  quality: integer = 85, JPEG quality (1-100)


Parameters for plugin 'SettingsPNG'
  compression: integer = 9, Compression for PNG output (0-9)
  bits_per_channel: integer = 8, Bits per channel (8 or 16)


Parameters for plugin 'SettingsEXR'
  compression: integer = 0, Compression for OpenEXR output (0 - default, 1 - no compression, 2 - RLE, 3 - ZIPS, 4 - ZIP, 5 - PIZ, 6 - pxr24)
  bits_per_channel: integer = 16, Bits per channel (16 or 32)
  extra_attributes: string = "", Extra attributes to write in the header


Parameters for plugin 'SettingsOutput'
  img_width: integer = 640, Output image width
  img_height: integer = 480, Output image height
  img_pixelAspect: float = 1, Output image pixel aspect
  img_file: string = "", Output image file
  img_dir: string = "", Output image dir
  img_file_needFrameNumber: bool = false, If true, the frame number is added to the image file name
  img_separateAlpha: bool = false, If true, the alpha channel will be written to a separate file
  img_noAlpha: bool = false, If true, the alpha channel will not be written the final image
  img_rawFile: bool = false, If true, V-Ray will render to a tiled file format (.vrimg or .exr). This is automatically turned on for file formats that only support tiled writing (like .vrimg)
  img_rawFileVFB: integer = 1, If writing to a tiled file format, specifies whether a memory VFB window should be displayed (0 - no memory VFB, 1 - full memory VFB, 2 - preview)
  anim_start: double = 0, Start of animation range
  anim_end: double = 1, End of animation range
  anim_frame_padding: integer = 4, Animation Frame Name Padding
  anim_renumber_on: bool = false, If true, frame renumbering is used
  anim_renumber_start: float = 0, Start number for renumber frames
  anim_renumber_step: float = 1, Renumber frames step
  anim_ren_frame_start: float = 0, First frame of animation range
  frame_start: integer = 0, The frame number at the start of the animation range
  frames_per_second: float = 1, Number of frames per unit time
  frames: integer, unlimited list, List of frames to be rendered. May contain intervals in the form of lists with start and end frame
  rgn_left: float = 0, Image output region left coord
  rgn_width: float = 640, Image output region width
  rgn_top: float = 0, Image output region top coord
  rgn_height: float = 480, Image output region height
  bmp_width: integer = 640, Output bitmap width
  bmp_height: integer = 480, Output bitmap height
  r_left: integer = 0, Bitmap output region left coord
  r_width: integer = 640, Bitmap output region width
  r_top: integer = 0, Bitmap output region top coord
  r_height: integer = 480, Bitmap output region height
  frame_stamp_enabled: bool = false, true to enable the VFB frame stamp
  frame_stamp_text: string = "", Frame stamp text
  relements_separateFolders: bool = false, true to save render elements in separate folders
  relements_divider: string = ".", Render elements name separator


Parameters for plugin 'SettingsOptions'
  geom_displacement: bool = true
  geom_doHidden: bool = true
  light_doLights: bool = true
  light_doDefaultLights: bool = true
  light_doHiddenLights: bool = true
  light_doShadows: bool = true
  light_onlyGI: bool = false
  gi_dontRenderImage: bool = false, Don't render final image
  mtl_reflectionRefraction: bool = true
  mtl_limitDepth: bool = false, Limit max depth
  mtl_maxDepth: integer = 5, Max. ray depth for reflections and refractions
  mtl_doMaps: bool = true
  mtl_filterMaps: bool = true
  mtl_filterMapsForSecondaryRays: bool = true, false to turn off filtering for glossy and GI rays
  mtl_transpMaxLevels: integer = 50, Max. transparency levels
  mtl_transpCutoff: float = 0.001, Transparency cutoff
  mtl_override_on: bool = false, Override material
  mtl_glossy: bool = true, Glossy effects
  geom_backfaceCull: bool = false, If true, back faces will be invisible to camera and shadow rays
  ray_bias: float = 0, Secondary ray bias
  misc_lowThreadPriority: bool = false


Parameters for plugin 'SettingsMotionBlur'
  on: bool = false
  geom_samples: integer = 2
  low_samples: integer = 1
  duration: float = 1
  subdivs: integer = 6
  bias: float = 0
  shutter_efficiency: float = 1
  interval_center: float = 0.5
  camera_motion_blur: bool = true


Parameters for plugin 'SettingsLightTree'
  on: bool = false
  solids_enabled: integer = 1
  build_quality: integer = 0


Parameters for plugin 'SettingsLightCache'
  subdivs: integer = 500
  sample_size: float = 0.02
  filter_type: integer = 1, 0 - no filter; 1 - nearest; 2 - fixed
  filter_samples: integer = 5
  filter_size: float = 0.06
  prefilter: bool = false
  prefilter_samples: integer = 10
  depth: integer = 100
  show_calc_phase: bool = true
  store_direct_light: bool = true
  world_scale: bool = false
  mode: integer = 0
  file: string = ""
  dont_delete: bool = true
  auto_save: bool = true
  auto_save_file: string = ""
  num_passes: integer = 4
  use_for_glossy_rays: bool = false
  adaptive_sampling: bool = false
  multiple_views: bool = false
  retrace_enabled: bool = false, true to enable retrace of light cache
  retrace_threshold: float = 1, retrace treshold, relative to the light cache sample size


Parameters for plugin 'SettingsIrradianceMap'
  min_rate: integer = -3
  max_rate: integer = 0
  subdivs: integer = 50
  interp_samples: integer = 20
  calc_interp_samples: integer = 15
  interp_frames: integer = 2
  color_threshold: float = 0.3
  normal_threshold: float = 0.1
  distance_threshold: float = 0.1
  detail_enhancement: bool = false
  detail_radius: float = 60
  detail_subdivs_mult: float = 60
  detail_scale: integer = 0
  randomize_samples: integer = 1
  interpolation_mode: integer = 1
  lookup_mode: integer = 3
  mode: integer = 0
  dont_delete: bool = true
  file: string = ""
  show_samples: bool = false
  show_calc_phase: bool = true
  show_direct_light: bool = false
  multiple_views: bool = false
  multipass: bool = true
  check_sample_visibility: bool = false
  auto_save: bool = false
  auto_save_file: string = ""


Parameters for plugin 'SettingsImageSampler'
  type: integer = 0
  fixed_subdivs: integer = 1
  dmc_minSubdivs: integer = 1
  dmc_maxSubdivs: integer = 4
  dmc_threshold: float = 0.01
  dmc_show_samples: bool = false
  subdivision_minRate: integer = -1
  subdivision_maxRate: integer = 2
  subdivision_jitter: bool = true
  subdivision_threshold: float = 0.15
  subdivision_edges: bool = false
  subdivision_normals: bool = false
  subdivision_normals_threshold: float = 0.1
  subdivision_show_samples: bool = false


Parameters for plugin 'SettingsGI'
  on: bool = false
  refract_caustics: bool = true
  reflect_caustics: bool = false
  saturation: float = 1
  contrast: float = 1
  contrast_base: float = 0.5
  primary_engine: integer = 0
  primary_multiplier: float = 1
  secondary_engine: integer = 2
  secondary_multiplier: float = 1
  ray_distance_on: bool = false
  ray_distance: float = 100000
  ao_on: bool = false
  ao_amount: float = 0.8
  ao_radius: float = 10
  ao_subdivs: integer = 8


Parameters for plugin 'SettingsEnvironment'
  bg_color: color = Color(0, 0, 0), Environment color
  bg_tex: acolor texture, Environment map
  bg_tex_mult: float = 1, Environment map multiplier
  gi_color: color = Color(0, 0, 0), GI (skylight) color
  gi_tex: acolor texture, GI (skylight) map
  gi_tex_mult: float = 1, GI (skylight) map multiplier
  reflect_color: color = Color(0, 0, 0), Reflection color
  reflect_tex: acolor texture, Reflection map
  reflect_tex_mult: float = 1, Reflection map multiplier
  refract_color: color = Color(0, 0, 0), Refraction color
  refract_tex: acolor texture, Refraction map
  refract_tex_mult: float = 1, Refraction map multiplier
  environment_volume: plugin, unlimited list, A list of environment volumes for the scene
  num_environment_objects: integer = 0, Used for implementing image planes
  global_light_level: color = Color(1, 1, 1), A global light level multiplier for all lights


Parameters for plugin 'SettingsDefaultDisplacement'
  override_on: bool = true
  edgeLength: float = 4, Max. height
  viewDependent: bool = true
  maxSubdivs: integer = 256
  tightBounds: bool = true
  amount: float = 1
  relative: bool = false


Parameters for plugin 'SettingsColorMapping'
  type: integer = 0
  affect_background: bool = true
  dark_mult: float = 1
  bright_mult: float = 1
  gamma: float = 1
  subpixel_mapping: bool = false
  clamp_output: bool = false
  clamp_level: float = 1, The level at which colors will be clamped if clamping is on
  adaptation_only: bool = false
  linearWorkflow: bool = false, true to enforce linear workflow
  exposure: color = Color(1, 1, 1), Additional image exposure


Parameters for plugin 'SettingsCaustics'
  on: bool = true
  max_photons: integer = 30
  search_distance: float = 1e+18
  max_density: float = 0
  multiplier: float = 1
  mode: integer = 0
  file: string = ""
  dont_delete: bool = true
  auto_save: bool = false
  auto_save_file: string = ""
  show_calc_phase: bool = false


Parameters for plugin 'SettingsCameraDof'
  on: bool = false
  aperture: float = 5
  center_bias: float = 0
  focal_dist: float = 200
  sides_on: bool = false
  sides_num: integer = 5
  rotation: float = 0
  anisotropy: float = 0
  subdivs: integer = 8


Parameters for plugin 'SettingsCamera'
  type: integer = 0, Camera type: 0 - default, 1 - spherical, 2 - cylindrical point, 3 - cylindrical ortho, 4 - box, 5 - fish-eye, 6 - warped spherical, 7 - orthogonal, 8 - pinhole
  height: float = 400, Height of the cylindrical (ortho) camera
  dist: float = 2, Applies only to fish-eye camera. Controls distance to the sphere center
  fov: float = 0.785398, Field of view; if negative, the field of view will not be modified
  auto_fit: bool = true, The auto-fit option of the fish-eye camera
  curve: float = 1, Controls the way the rendered images is warped. Applies only to fish-eye camera
  dont_affect_settings: bool = false, This is here so we can suppress a SettingsCamera node from affecting the main VRayRenderer sequence and frame data.


Parameters for plugin 'RenderView'
  transform: transform
  fov: float = 0.785398
  focalDistance: float = 1
  aperture: float = 0.1
  lens_rotation: float = 0
  frame_samples: integer = 2, Number of samples per frame for the transformation
  clipping: bool = false, true to enable clipping planes
  clipping_near: float = 0, The near clipping plane
  clipping_far: float = 1e+18, The far clipping plane
  zoom: float = 1, Zoom factor
  orthographic: bool = false
  orthographicWidth: float = 1
  dont_affect_settings: bool = false, This is here so we can suppress a RenderView node from affecting the main VRayRenderer sequence and frame data.
  use_scene_offset: bool = true, If true, the scene will be internally translated relative to the render view


Parameters for plugin 'RenderChannelObjectSelect'
  name: string = "ObjectSelect"
  id: integer = 0, The object/material ID that will be extracted
  use_mtl_id: bool = false, true to use the material IDs instead of the object IDs
  affect_matte_objects: bool = true, false to not affect Matte Objects
  consider_for_aa: bool = false


Parameters for plugin 'RenderChannelMultiMatte'
  name: string = "MultiMatte"
  red_id: integer = 0, The object ID that will be written as the red channel (0 to disable the red channel)
  green_id: integer = 0, The object ID that will be written as the green channel (0 to disable the green channel)
  blue_id: integer = 0, The object ID that will be written as the blue channel (0 to disable the blue channel)
  use_mtl_id: bool = false, true to use the material IDs instead of the object IDs
  affect_matte_objects: bool = true, false to not affect Matte Objects


Parameters for plugin 'RenderChannelDRBucket'
  name: string = "DR"
  text_alignment: integer = 1


Parameters for plugin 'RenderChannelNodeID'
  name: string = "ObjectID"


Parameters for plugin 'RenderChannelCoverage'
  name: string = "Coverage"


Parameters for plugin 'RenderChannelExtraTex'
  name: string = "ExtraTexChannel"
  consider_for_aa: bool = true
  affect_matte_objects: bool = true
  texmap: acolor texture = AColor(0, 0, 0, 1)
  filtering: bool = true


Parameters for plugin 'RenderChannelVelocity'
  name: string = "Velocity"
  clamp_velocity: bool = true
  max_velocity: float = 1
  max_velocity_last_frame: float = 0
  ignore_z: bool = true
  filtering: bool = true


Parameters for plugin 'RenderChannelRenderID'
  name: string = "RenderID"


Parameters for plugin 'RenderChannelZDepth'
  name: string = "ZDepth"
  depth_from_camera: bool = false
  depth_black: float = 0
  depth_white: float = 1000
  depth_clamp: bool = true
  filtering: bool = true


Parameters for plugin 'RenderChannelBumpNormals'
  name: string = "BumpNormals"
  filtering: bool = true


Parameters for plugin 'RenderChannelNormals'
  name: string = "Normals"
  filtering: bool = true


Parameters for plugin 'RenderChannelColor'
  name: string = "ColorChannel"
  alias: integer = 1000
  color_mapping: bool = false, true to apply color mapping to the channel; false otherwise
  consider_for_aa: bool = false
  filtering: bool = true


Parameters for plugin 'RTEngine'
  enabled: bool = true, true to enable the RT engine and false to disable it
  separate_window: bool = true, true to open a separate window for the RTEngine, and false to use the V-Ray VFB
  trace_depth: integer = 5, Maximum trace depth for reflections/refractions etc.
  use_gi: bool = true, true to render GI and false otherwise.
  gi_depth: integer = 3, Maximum trace depth for GI.
  gi_reflective_caustics: bool = false, true to render reflective GI caustics
  gi_refractive_caustics: bool = true, true to render refractive GI caustics
  bundle_size: integer = 128, Number of samples to transfer over the network.
  samples_per_pixel: integer = 4, Number of samples per pixel.
  coherent_tracing: bool = false, true to enable coherent tracing of gi/reflections/refractions etc.
  use_opencl: bool = false
  stereo_mode: integer = 0, Non-zero to enable side-by-side stereo rendering.
  stereo_eye_distance: float = 6.5, Distance between the two cameras for stereo mode.
  stereo_focus: integer = 2, Focus mode (0 - none, 1 - rotation, 2 - shear)
  opencl_texsize: integer = 512, OpenCL Single Kernel maximum texture size - bigger textures are scaled to fit this size


Parameters for plugin 'OutputTest'


Parameters for plugin 'Node'
  transform: transform
  geometry: plugin
  material: plugin
  volume: plugin
  nsamples: integer = 0, Number of transform samples
  lights: plugin, unlimited list
  visible: bool = true, true if the object is renderable (visible) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
  user_attributes: string = "", A list of user defined attributes
  objectID: integer = 0, Object ID for the rendering
  primary_visibility: bool = true, If off shading an intersection with this mesh will not generate a gbuffer.


Parameters for plugin 'NewGI'


Parameters for plugin 'MtlWrapperMaya'
  base_material: plugin, The base material
  generate_gi: float = 1, Controls the GI generated by the material.
  receive_gi: float = 1, Controls the GI received by the material.
  generate_caustics: float = 1, Controls the caustics generated by the material.
  receive_caustics: float = 1, Controls the caustics received by the material.
  alpha_contribution: float = 1, The contribution of the resulting color to the alpha channel.
  matte_surface: bool = false, Makes the material appear as a matte material, which shows the background, instead of the base material, when viewed directly.
  shadows: bool = false, Turn this on to make shadow visible on the matter surface.
  affect_alpha: bool = false, Turn this on to make shadows affect the alpha contribution of the matte surface.
  shadow_tint_color: color = Color(0, 0, 0), Tint for the shadows on the matte surface.
  shadow_brightness: float = 1, An optional brightness parameter for the shadows on the matte surface.A value of 0.0 will make the shadows completely invisible, while a value of 1.0 will show the full shadows.
  reflection_amount: float = 1, Shows the reflections of the base material.
  refraction_amount: float = 1, Shows the refractions of the base material.
  gi_amount: float = 1, Determines the amount of gi shadows.
  no_gi_on_other_mattes: bool = true, This will cause the material to appear as a matte object in reflections, refractions, GI etc for other matte objects.
  matte_for_secondary_rays: bool = false, Turn this on to make the material act as matte for all secondary rays (reflections, refractions, etc)
  gi_surface_id: integer = 0, If two objects have different GI surface ids, the light cache samples of the two objects will not be blended
  gi_quality_multiplier: float = 1, A multiplier for GI quality
  maya_background_shader_compatibility: bool = false, Setting this to true will make the matte alpha opaque so that the alpha of objects behind the matte won't be seen.
  alpha_contribution_tex: float texture = 1, Same as alpha_contribution but used for the Maya's useBackground shader which supports textures as alpha contribution
  shadow_brightness_tex: float texture = 1, Same as shadow_brightness but used for the Maya's useBackground shader which supports textures as shadow brightness
  reflection_filter_tex: acolor texture = AColor(1, 1, 1, 1)
  trace_depth: integer = -1, The maximum reflection depth (-1 is controlled by the global options)
  channels: plugin, unlimited list, Render channels the result of this BRDF will be written to


Parameters for plugin 'MtlWrapper'
  base_material: plugin, The base material
  generate_gi: float = 1, Controls the GI generated by the material.
  receive_gi: float = 1, Controls the GI received by the material.
  generate_caustics: float = 1, Controls the caustics generated by the material.
  receive_caustics: float = 1, Controls the caustics received by the material.
  alpha_contribution: float = 1, The contribution of the resulting color to the alpha channel.
  matte_surface: bool = false, Makes the material appear as a matte material, which shows the background, instead of the base material, when viewed directly.
  shadows: bool = false, Turn this on to make shadow visible on the matter surface.
  affect_alpha: bool = false, Turn this on to make shadows affect the alpha contribution of the matte surface.
  shadow_tint_color: color = Color(0, 0, 0), Tint for the shadows on the matte surface.
  shadow_brightness: float = 1, An optional brightness parameter for the shadows on the matte surface.A value of 0.0 will make the shadows completely invisible, while a value of 1.0 will show the full shadows.
  reflection_amount: float = 1, Shows the reflections of the base material.
  refraction_amount: float = 1, Shows the refractions of the base material.
  gi_amount: float = 1, Determines the amount of gi shadows.
  no_gi_on_other_mattes: bool = true, This will cause the material to appear as a matte object in reflections, refractions, GI etc for other matte objects.
  matte_for_secondary_rays: bool = false, Turn this on to make the material act as matte for all secondary rays (reflections, refractions, etc)
  gi_surface_id: integer = 0, If two objects have different GI surface ids, the light cache samples of the two objects will not be blended
  gi_quality_multiplier: float = 1, A multiplier for GI quality
  maya_background_shader_compatibility: bool = false, Setting this to true will make the matte alpha opaque so that the alpha of objects behind the matte won't be seen.
  alpha_contribution_tex: float texture = 1, Same as alpha_contribution but used for the Maya's useBackground shader which supports textures as alpha contribution
  shadow_brightness_tex: float texture = 1, Same as shadow_brightness but used for the Maya's useBackground shader which supports textures as shadow brightness
  reflection_filter_tex: acolor texture = AColor(1, 1, 1, 1)
  trace_depth: integer = -1, The maximum reflection depth (-1 is controlled by the global options)
  channels: plugin, unlimited list, Render channels the result of this BRDF will be written to


Parameters for plugin 'MtlSingleBRDF'
  filter: color = Color(1, 1, 1)
  brdf: plugin
  double_sided: bool = true, 1 to make the material double-sided
  allow_negative_colors: bool = false, true to allow negative color components; otherwise they will be clamped to 0


Parameters for plugin 'MtlRoundEdges'
  base_mtl: plugin, Base material
  radius: float texture, Rounding radius


Parameters for plugin 'MtlRenderStats'
  base_mtl: plugin, Base material
  camera_visibility: bool = true
  reflections_visibility: bool = true
  refractions_visibility: bool = true
  gi_visibility: bool = true
  shadows_visibility: bool = true
  visibility: float = 1, Overall visibility


Parameters for plugin 'MtlMayaRamp'
  color_positions: float = 0.5, positions of the color ramp
  color_colors: acolor texture, unlimited list, colors of the color ramp
  color_interpolations: integer = 0, 0: none, 1: linear, 2: smooth, 3: spline
  color_input: integer = 0, 0: light angle, 1: facing angle, 2: brightness, 3: normalized brightness
  transp_positions: float = 0.5, positions of the transparency ramp
  transp_colors: acolor texture, unlimited list, colors of the transparency ramp
  transp_interpolations: integer = 0, 0: none, 1: linear, 2: smooth, 3: spline
  incan_positions: float = 0.5, positions of the incandescence ramp
  incan_colors: acolor texture, unlimited list, colors of the incandescence ramp
  incan_interpolations: integer = 0, 0: none, 1: linear, 2: smooth, 3: spline
  specular_positions: float = 0.5, positions of the specular ramp
  specular_colors: acolor texture, unlimited list, colors of the specular ramp
  specular_interpolations: integer = 0, 0: none, 1: linear, 2: smooth, 3: spline
  environm_positions: float = 0.5, positions of the environment ramp
  environm_colors: acolor texture, unlimited list, colors of the environment ramp
  environm_interpolations: integer = 0, 0: none, 1: linear, 2: smooth, 3: spline
  specularRollOff_positions: float = 0.5, positions of the specular roll off ramp
  specularRollOff_values: float texture, unlimited list, values of the specular roll off ramp
  specularRollOff_interpolations: integer = 0, 0: none, 1: linear, 2: smooth, 3: spline
  reflectivity_positions: float = 0.5, positions of the reflectivity ramp
  reflectivity_values: float texture, unlimited list, values of the reflectivity ramp
  reflectivity_interpolations: integer = 0, 0: none, 1: linear, 2: smooth, 3: spline
  ambient_tex: acolor texture, unlimited list, ambient texture
  eccentricity_tex: float texture, unlimited list, eccentricity float texture
  specularity_tex: float texture, unlimited list, specularity float texture
  diffuse_tex: float texture, unlimited list, diffuse float texture
  fscatter_tex: float texture, unlimited list, forward scatter float texture
  reflection_limit: integer = 0, reflection limit
  refractions: bool = false
  ior: float = 1.55, IOR for the material; this is ignored if the surface has a volume shader (the volume IOR is used).
  refraction_limit: integer = -1, The maximum refraction bounces
  volume: plugin
  bump_brdf: plugin, bump BRDF


Parameters for plugin 'MtlOverride'
  base_mtl: plugin, The normal material (visible to the camera)
  gi_mtl: plugin, The gi material
  reflect_mtl: plugin, The reflection material
  refract_mtl: plugin, The refraction material
  shadow_mtl: plugin, The shadow material
  environment_override: acolor texture, Environment override texture
  environment_priority: integer = 0, Environment override priority (used when several materials override it along a ray path)


Parameters for plugin 'MtlMulti'
  mtls: plugin, unlimited list, (Deprecated; use mtls_list/ids_list instead). A list of two-element lists with the material id and the material plugin.
  mtls_list: plugin, unlimited list, A list of the materials.
  ids_list: integer, unlimited list, A list of material IDs
  mtlid_gen: integer texture, An integer texture that generates material ids; if not present, the surface material id will be used.
  wrap_id: bool = false, true to wrap the material ID's to the largest specified ID for the material


Parameters for plugin 'MtlMaterialID'
  base_mtl: plugin, The base material
  material_id_color: acolor texture = AColor(0, 0, 0, 1), The material id color
  material_id_number: integer = 0


Parameters for plugin 'MtlLayeredBRDF'
  brdfs: plugin, unlimited list
  double_sided: bool = true, 1 to make the material double-sided


Parameters for plugin 'MtlDoubleSided'
  base_mtl: plugin, Base material


Parameters for plugin 'MtlDiffuse'
  diffuse: color = Color(0.5, 0.5, 0.5)
  diffuse_tex: acolor texture
  diffuse_tex_mult: float = 1
  reflection: color = Color(0, 0, 0)
  transparency: color = Color(0, 0, 0)
  render_channel_color: plugin
  render_channel_alpha: plugin


Parameters for plugin 'MtlBump'
  base_mtl: plugin, Base material
  bump_tex_color: acolor texture, Bump texture
  bump_tex_float: float texture, Bump texture
  bump_tex_mult: float = 1, Bump amount
  bump_tex_mult_tex: float texture, Bump amount texture
  bump_tex: plugin, Bump texture; this is deprecated, use bump_tex_color or bump_tex_float instead
  bump_shadows: bool = false, true to offset the surface shading point, in addition to the normal
  bump_delta_scale: float = 1, Scale for sampling the bitmap when map_type is 0. Normally this is tied to the ray differentials, but can be changed if necessary.
  maya_compatible: bool = false, When this is true the BRDFBump will try to match the Maya bump/normal mapping
  map_type: integer = 0, The type of the map (0 - from regular texture output, 1 - normal map in tangent space, 2 - normal map in object space, 3 - normal map in camera space, 4 - normal map in world space, 5 - from texture bump output, 6 - explicit normal)
  normal_uvwgen: plugin, The uvw generator for the normal map texture when map_type is 1.
  compute_bump_for_shadows: bool = true, true to compute bump mapping for shadow rays in case the material is transparent; false to skip the bump map for shadow rays (faster rendering)


Parameters for plugin 'Mtl2Sided'
  front: plugin, The material for the surface on the same side as the normal
  back: plugin, The material for the side that is opposite the surface normal
  translucency: color = Color(0, 0, 0), Translucency between front and back
  translucency_tex: acolor texture, Translucency texture
  translucency_tex_mult: float = 1, Multiplier for the translucency texture
  force_1sided: bool = true, 1 to make the sub-materials one-sided
  channels: plugin, unlimited list, Render channels the result of this BRDF will be written to


Parameters for plugin 'MayaLightDirect'
  color: color = Color(1, 1, 1), Color of the light
  color_tex: acolor texture, A color texture that if present will override the color parameter
  intensity: float = 1, Light intensity
  intensity_tex: float texture, A float texture that if present will override the intensity parameter
  transform: transform
  shadowBias: float = 0, Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
  photonSubdivs: integer = 500
  causticSubdivs: integer = 1000
  shadows: bool = true
  shadowRadius: float = 0, The size of the light; 0.0 is a point light, larger values produces soft (area) shadows
  shadowSubdivs: integer = 8
  shadowColor: color = Color(0, 0, 0), The shadow color. Anything but black is not physically accurate.
  shadowColor_tex: acolor texture, A color texture that if present will override the shadowColor parameter
  enabled: bool = true, true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
  affectDiffuse: bool = true, true if the light produces diffuse lighting and false otherwise
  affectSpecular: bool = true, true if the light produces specular hilights and false otherwise
  nsamples: integer = 0, Number of parameter samples for motion blur.
  channels: plugin, unlimited list, Render channels the result of this light will be written to
  channels_raw: plugin, unlimited list, Render channels the raw diffuse result of this light will be written to
  channels_diffuse: plugin, unlimited list, Render channels the diffuse result of this light will be written to
  channels_specular: plugin, unlimited list, Render channels the specular result of this light will be written to


Parameters for plugin 'LightSpot'
  enabled: bool = true, true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
  transform: transform
  color: color = Color(1, 1, 1), Color of the light
  color_tex: acolor texture, A color texture that if present will override the color parameter
  shadows: bool = true, true if the light casts shadows and false otherwise
  shadowColor: color = Color(0, 0, 0), The shadow color. Anything but black is not physically accurate.
  shadowColor_tex: acolor texture, A color texture that if present will override the shadowColor parameter
  shadowBias: float = 0, Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
  photonSubdivs: integer = 500
  causticSubdivs: integer = 1000
  diffuseMult: float = 1, Multiplier for the diffuse photons.
  causticMult: float = 1, Multiplier for the caustic photons.
  cutoffThreshold: float = 0.001, Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
  affectDiffuse: bool = true, true if the light produces diffuse lighting and false otherwise
  affectSpecular: bool = true, true if the light produces specular hilights and false otherwise
  bumped_below_surface_check: bool = false, true if the bumped normal should be used to check if the light dir is below the surface
  nsamples: integer = 0, Number of parameter samples for motion blur.
  diffuse_contribution: float = 1, Diffuse contribution for the light
  specular_contribution: float = 1, Specular contribution for the light
  channels: plugin, unlimited list, Render channels the result of this light will be written to
  channels_raw: plugin, unlimited list, Render channels the raw diffuse result of this light will be written to
  channels_diffuse: plugin, unlimited list, Render channels the diffuse result of this light will be written to
  channels_specular: plugin, unlimited list, Render channels the specular result of this light will be written to
  use_global_light_level: bool = true, true if the light should use the global light level setting
  units: integer = 0, Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
  intensity: float = 1, Light intensity
  intensity_tex: float texture, A float texture that if present will override the intensity parameter
  shadowRadius: float = 0, The size of the light; 0.0 is a point light, larger values produces soft (area) shadows
  areaSpeculars: bool = false, If true, the hilights will match the shape of the light; if false, hilights will always be calculated as from a point light
  shadowSubdivs: integer = 8
  coneAngle: float = 1, The entire spot cone, in radians
  penumbraAngle: float = 0, The penumbra region, in radians; positive is outside the spot cone; negative is inside
  dropOff: float = 0, The dropOff attribute
  falloffType: integer = 0, The type of transition in the penumbra region; 0 - linear; 1 - smooth cubic
  decay: float = 2
  barnDoor: bool = false, true to produce a barn door effect.
  barnDoorLeft: float = 20, angle between the light direction and the left barn door
  barnDoorRight: float = 20, angle between the light direction and the right barn door
  barnDoorTop: float = 20, angle between the light direction and the top barn door
  barnDoorBottom: float = 20, angle between the light direction and the bottom barn door
  useDecayRegions: bool = false, True to use decay regions.
  startDistance1: float = 1, Start of first decay region
  endDistance1: float = 2, End of first decay region
  startDistance2: float = 3, Start of second decay region
  endDistance2: float = 6, End of second decay region
  startDistance3: float = 8, Start of third decay region
  endDistance3: float = 10, End of third decay region


Parameters for plugin 'LightSphere'
  enabled: bool = true, true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
  transform: transform
  color: color = Color(1, 1, 1), Color of the light
  color_tex: acolor texture, A color texture that if present will override the color parameter
  shadows: bool = true, true if the light casts shadows and false otherwise
  shadowColor: color = Color(0, 0, 0), The shadow color. Anything but black is not physically accurate.
  shadowColor_tex: acolor texture, A color texture that if present will override the shadowColor parameter
  shadowBias: float = 0, Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
  photonSubdivs: integer = 500
  causticSubdivs: integer = 1000
  diffuseMult: float = 1, Multiplier for the diffuse photons.
  causticMult: float = 1, Multiplier for the caustic photons.
  cutoffThreshold: float = 0.001, Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
  affectDiffuse: bool = true, true if the light produces diffuse lighting and false otherwise
  affectSpecular: bool = true, true if the light produces specular hilights and false otherwise
  bumped_below_surface_check: bool = false, true if the bumped normal should be used to check if the light dir is below the surface
  nsamples: integer = 0, Number of parameter samples for motion blur.
  diffuse_contribution: float = 1, Diffuse contribution for the light
  specular_contribution: float = 1, Specular contribution for the light
  channels: plugin, unlimited list, Render channels the result of this light will be written to
  channels_raw: plugin, unlimited list, Render channels the raw diffuse result of this light will be written to
  channels_diffuse: plugin, unlimited list, Render channels the diffuse result of this light will be written to
  channels_specular: plugin, unlimited list, Render channels the specular result of this light will be written to
  use_global_light_level: bool = true, true if the light should use the global light level setting
  units: integer = 0, Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
  intensity: float = 1, Light intensity
  intensity_tex: float texture, A float texture that if present will override the intensity parameter
  subdivs: integer = 8
  storeWithIrradianceMap: bool = false
  invisible: bool = false
  affectReflections: bool = true, true if the light appears in reflections and false otherwise
  noDecay: bool = false
  objectID: integer = 0
  radius: float = 1
  sphere_segments: integer = 20


Parameters for plugin 'LightRectangle'
  enabled: bool = true, true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
  transform: transform
  color: color = Color(1, 1, 1), Color of the light
  color_tex: acolor texture, A color texture that if present will override the color parameter
  shadows: bool = true, true if the light casts shadows and false otherwise
  shadowColor: color = Color(0, 0, 0), The shadow color. Anything but black is not physically accurate.
  shadowColor_tex: acolor texture, A color texture that if present will override the shadowColor parameter
  shadowBias: float = 0, Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
  photonSubdivs: integer = 500
  causticSubdivs: integer = 1000
  diffuseMult: float = 1, Multiplier for the diffuse photons.
  causticMult: float = 1, Multiplier for the caustic photons.
  cutoffThreshold: float = 0.001, Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
  affectDiffuse: bool = true, true if the light produces diffuse lighting and false otherwise
  affectSpecular: bool = true, true if the light produces specular hilights and false otherwise
  bumped_below_surface_check: bool = false, true if the bumped normal should be used to check if the light dir is below the surface
  nsamples: integer = 0, Number of parameter samples for motion blur.
  diffuse_contribution: float = 1, Diffuse contribution for the light
  specular_contribution: float = 1, Specular contribution for the light
  channels: plugin, unlimited list, Render channels the result of this light will be written to
  channels_raw: plugin, unlimited list, Render channels the raw diffuse result of this light will be written to
  channels_diffuse: plugin, unlimited list, Render channels the diffuse result of this light will be written to
  channels_specular: plugin, unlimited list, Render channels the specular result of this light will be written to
  use_global_light_level: bool = true, true if the light should use the global light level setting
  units: integer = 0, Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
  intensity: float = 1, Light intensity
  intensity_tex: float texture, A float texture that if present will override the intensity parameter
  subdivs: integer = 8
  storeWithIrradianceMap: bool = false
  invisible: bool = false
  affectReflections: bool = true, true if the light appears in reflections and false otherwise
  noDecay: bool = false
  doubleSided: bool = false
  lightPortal: integer = 0, Specifies if the light is a portal light (0 - normal light, 1 - portal light, 2 - simple portal light)
  objectID: integer = 0
  u_size: float = 1, The u dimension of the light (actually half-width)
  v_size: float = 1, The v dimension of the light (actually half-height)
  ignoreLightNormals: bool = true
  rect_tex: acolor texture, The light texture
  use_rect_tex: bool = false, true if the texture should be used
  tex_resolution: integer = 512, The texture presampling resolution
  tex_adaptive: float = 1, The adaptivity of the sampling to the texture brightness (0.0 - no adaptivity; 1.0 - full adaptivity


Parameters for plugin 'LightAmbient'
  enabled: bool = true, true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
  transform: transform
  color: color = Color(1, 1, 1), Color of the light
  color_tex: acolor texture, A color texture that if present will override the color parameter
  shadows: bool = true, true if the light casts shadows and false otherwise
  shadowColor: color = Color(0, 0, 0), The shadow color. Anything but black is not physically accurate.
  shadowColor_tex: acolor texture, A color texture that if present will override the shadowColor parameter
  shadowBias: float = 0, Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
  photonSubdivs: integer = 500
  causticSubdivs: integer = 1000
  diffuseMult: float = 1, Multiplier for the diffuse photons.
  causticMult: float = 1, Multiplier for the caustic photons.
  cutoffThreshold: float = 0.001, Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
  affectDiffuse: bool = true, true if the light produces diffuse lighting and false otherwise
  affectSpecular: bool = true, true if the light produces specular hilights and false otherwise
  bumped_below_surface_check: bool = false, true if the bumped normal should be used to check if the light dir is below the surface
  nsamples: integer = 0, Number of parameter samples for motion blur.
  diffuse_contribution: float = 1, Diffuse contribution for the light
  specular_contribution: float = 1, Specular contribution for the light
  channels: plugin, unlimited list, Render channels the result of this light will be written to
  channels_raw: plugin, unlimited list, Render channels the raw diffuse result of this light will be written to
  channels_diffuse: plugin, unlimited list, Render channels the diffuse result of this light will be written to
  channels_specular: plugin, unlimited list, Render channels the specular result of this light will be written to
  use_global_light_level: bool = true, true if the light should use the global light level setting
  units: integer = 0, Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
  intensity: float = 1, Light intensity
  intensity_tex: float texture, A float texture that if present will override the intensity parameter
  shadowRadius: float = 0, The size of the light; 0.0 is a point light, larger values produces soft (area) shadows
  areaSpeculars: bool = false, If true, the hilights will match the shape of the light; if false, hilights will always be calculated as from a point light
  shadowSubdivs: integer = 8
  decay: float = 2
  ambient_shade: float texture = 0.45


Parameters for plugin 'LightOmni'
  enabled: bool = true, true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
  transform: transform
  color: color = Color(1, 1, 1), Color of the light
  color_tex: acolor texture, A color texture that if present will override the color parameter
  shadows: bool = true, true if the light casts shadows and false otherwise
  shadowColor: color = Color(0, 0, 0), The shadow color. Anything but black is not physically accurate.
  shadowColor_tex: acolor texture, A color texture that if present will override the shadowColor parameter
  shadowBias: float = 0, Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
  photonSubdivs: integer = 500
  causticSubdivs: integer = 1000
  diffuseMult: float = 1, Multiplier for the diffuse photons.
  causticMult: float = 1, Multiplier for the caustic photons.
  cutoffThreshold: float = 0.001, Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
  affectDiffuse: bool = true, true if the light produces diffuse lighting and false otherwise
  affectSpecular: bool = true, true if the light produces specular hilights and false otherwise
  bumped_below_surface_check: bool = false, true if the bumped normal should be used to check if the light dir is below the surface
  nsamples: integer = 0, Number of parameter samples for motion blur.
  diffuse_contribution: float = 1, Diffuse contribution for the light
  specular_contribution: float = 1, Specular contribution for the light
  channels: plugin, unlimited list, Render channels the result of this light will be written to
  channels_raw: plugin, unlimited list, Render channels the raw diffuse result of this light will be written to
  channels_diffuse: plugin, unlimited list, Render channels the diffuse result of this light will be written to
  channels_specular: plugin, unlimited list, Render channels the specular result of this light will be written to
  use_global_light_level: bool = true, true if the light should use the global light level setting
  units: integer = 0, Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
  intensity: float = 1, Light intensity
  intensity_tex: float texture, A float texture that if present will override the intensity parameter
  shadowRadius: float = 0, The size of the light; 0.0 is a point light, larger values produces soft (area) shadows
  areaSpeculars: bool = false, If true, the hilights will match the shape of the light; if false, hilights will always be calculated as from a point light
  shadowSubdivs: integer = 8
  decay: float = 2


Parameters for plugin 'LightMesh'
  enabled: bool = true, true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
  transform: transform
  color: color = Color(1, 1, 1), Color of the light
  color_tex: acolor texture, A color texture that if present will override the color parameter
  shadows: bool = true, true if the light casts shadows and false otherwise
  shadowColor: color = Color(0, 0, 0), The shadow color. Anything but black is not physically accurate.
  shadowColor_tex: acolor texture, A color texture that if present will override the shadowColor parameter
  shadowBias: float = 0, Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
  photonSubdivs: integer = 500
  causticSubdivs: integer = 1000
  diffuseMult: float = 1, Multiplier for the diffuse photons.
  causticMult: float = 1, Multiplier for the caustic photons.
  cutoffThreshold: float = 0.001, Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
  affectDiffuse: bool = true, true if the light produces diffuse lighting and false otherwise
  affectSpecular: bool = true, true if the light produces specular hilights and false otherwise
  bumped_below_surface_check: bool = false, true if the bumped normal should be used to check if the light dir is below the surface
  nsamples: integer = 0, Number of parameter samples for motion blur.
  diffuse_contribution: float = 1, Diffuse contribution for the light
  specular_contribution: float = 1, Specular contribution for the light
  channels: plugin, unlimited list, Render channels the result of this light will be written to
  channels_raw: plugin, unlimited list, Render channels the raw diffuse result of this light will be written to
  channels_diffuse: plugin, unlimited list, Render channels the diffuse result of this light will be written to
  channels_specular: plugin, unlimited list, Render channels the specular result of this light will be written to
  use_global_light_level: bool = true, true if the light should use the global light level setting
  units: integer = 0, Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
  intensity: float = 1, Light intensity
  intensity_tex: float texture, A float texture that if present will override the intensity parameter
  subdivs: integer = 8
  storeWithIrradianceMap: bool = false
  invisible: bool = false
  affectReflections: bool = true, true if the light appears in reflections and false otherwise
  noDecay: bool = false
  doubleSided: bool = false
  lightPortal: integer = 0, Specifies if the light is a portal light (0 - normal light, 1 - portal light, 2 - simple portal light)
  objectID: integer = 0
  geometry: plugin
  ignoreLightNormals: bool = true
  tex: acolor texture, The light texture
  use_tex: bool = false, true if the texture should be used
  tex_resolution: integer = 256, The internal texture resolution
  cache_tex: bool = true, When this is true the texture will be cached at tex_resolution x tex_resolution and this cached texture will be used to determine the texture color for shadows rays(speeding up light evaluation, especially for complex procedural textures)


Parameters for plugin 'LightIESMax'
  enabled: bool = true, true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
  transform: transform
  color: color = Color(1, 1, 1), Color of the light
  color_tex: acolor texture, A color texture that if present will override the color parameter
  shadows: bool = true, true if the light casts shadows and false otherwise
  shadowColor: color = Color(0, 0, 0), The shadow color. Anything but black is not physically accurate.
  shadowColor_tex: acolor texture, A color texture that if present will override the shadowColor parameter
  shadowBias: float = 0, Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
  photonSubdivs: integer = 500
  causticSubdivs: integer = 1000
  diffuseMult: float = 1, Multiplier for the diffuse photons.
  causticMult: float = 1, Multiplier for the caustic photons.
  cutoffThreshold: float = 0.001, Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
  affectDiffuse: bool = true, true if the light produces diffuse lighting and false otherwise
  affectSpecular: bool = true, true if the light produces specular hilights and false otherwise
  bumped_below_surface_check: bool = false, true if the bumped normal should be used to check if the light dir is below the surface
  nsamples: integer = 0, Number of parameter samples for motion blur.
  diffuse_contribution: float = 1, Diffuse contribution for the light
  specular_contribution: float = 1, Specular contribution for the light
  channels: plugin, unlimited list, Render channels the result of this light will be written to
  channels_raw: plugin, unlimited list, Render channels the raw diffuse result of this light will be written to
  channels_diffuse: plugin, unlimited list, Render channels the diffuse result of this light will be written to
  channels_specular: plugin, unlimited list, Render channels the specular result of this light will be written to
  use_global_light_level: bool = true, true if the light should use the global light level setting
  shadowSubdivs: integer = 8
  ies_file: string = "", IES file with luminaire description
  filter_color: color = Color(1, 1, 1)
  soft_shadows: bool = false, true to use the shape of the light as described in the IES profile
  area_speculars: bool = true, true to cause specular highlights produced by the light to match the light shape; false to always produce speculars as a point light
  power: float = 0, Limuous power (in lm); if zero, the default lumious power from the IES profile is used.


Parameters for plugin 'LightIES'
  enabled: bool = true, true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
  transform: transform
  color: color = Color(1, 1, 1), Color of the light
  color_tex: acolor texture, A color texture that if present will override the color parameter
  shadows: bool = true, true if the light casts shadows and false otherwise
  shadowColor: color = Color(0, 0, 0), The shadow color. Anything but black is not physically accurate.
  shadowColor_tex: acolor texture, A color texture that if present will override the shadowColor parameter
  shadowBias: float = 0, Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
  photonSubdivs: integer = 500
  causticSubdivs: integer = 1000
  diffuseMult: float = 1, Multiplier for the diffuse photons.
  causticMult: float = 1, Multiplier for the caustic photons.
  cutoffThreshold: float = 0.001, Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
  affectDiffuse: bool = true, true if the light produces diffuse lighting and false otherwise
  affectSpecular: bool = true, true if the light produces specular hilights and false otherwise
  bumped_below_surface_check: bool = false, true if the bumped normal should be used to check if the light dir is below the surface
  nsamples: integer = 0, Number of parameter samples for motion blur.
  diffuse_contribution: float = 1, Diffuse contribution for the light
  specular_contribution: float = 1, Specular contribution for the light
  channels: plugin, unlimited list, Render channels the result of this light will be written to
  channels_raw: plugin, unlimited list, Render channels the raw diffuse result of this light will be written to
  channels_diffuse: plugin, unlimited list, Render channels the diffuse result of this light will be written to
  channels_specular: plugin, unlimited list, Render channels the specular result of this light will be written to
  use_global_light_level: bool = true, true if the light should use the global light level setting
  shadowSubdivs: integer = 8
  ies_file: string = "", IES file with luminaire description
  filter_color: color = Color(1, 1, 1)
  soft_shadows: bool = false, true to use the shape of the light as described in the IES profile
  area_speculars: bool = true, true to cause specular highlights produced by the light to match the light shape; false to always produce speculars as a point light
  power: float = 0, Limuous power (in lm); if zero, the default lumious power from the IES profile is used.


Parameters for plugin 'LightDome'
  enabled: bool = true, true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
  transform: transform
  color: color = Color(1, 1, 1), Color of the light
  color_tex: acolor texture, A color texture that if present will override the color parameter
  shadows: bool = true, true if the light casts shadows and false otherwise
  shadowColor: color = Color(0, 0, 0), The shadow color. Anything but black is not physically accurate.
  shadowColor_tex: acolor texture, A color texture that if present will override the shadowColor parameter
  shadowBias: float = 0, Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
  photonSubdivs: integer = 500
  causticSubdivs: integer = 1000
  diffuseMult: float = 1, Multiplier for the diffuse photons.
  causticMult: float = 1, Multiplier for the caustic photons.
  cutoffThreshold: float = 0.001, Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
  affectDiffuse: bool = true, true if the light produces diffuse lighting and false otherwise
  affectSpecular: bool = true, true if the light produces specular hilights and false otherwise
  bumped_below_surface_check: bool = false, true if the bumped normal should be used to check if the light dir is below the surface
  nsamples: integer = 0, Number of parameter samples for motion blur.
  diffuse_contribution: float = 1, Diffuse contribution for the light
  specular_contribution: float = 1, Specular contribution for the light
  channels: plugin, unlimited list, Render channels the result of this light will be written to
  channels_raw: plugin, unlimited list, Render channels the raw diffuse result of this light will be written to
  channels_diffuse: plugin, unlimited list, Render channels the diffuse result of this light will be written to
  channels_specular: plugin, unlimited list, Render channels the specular result of this light will be written to
  use_global_light_level: bool = true, true if the light should use the global light level setting
  units: integer = 0, Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
  intensity: float = 1, Light intensity
  intensity_tex: float texture, A float texture that if present will override the intensity parameter
  subdivs: integer = 8
  storeWithIrradianceMap: bool = false
  invisible: bool = false
  affectReflections: bool = true, true if the light appears in reflections and false otherwise
  objectID: integer = 0
  dome_tex: acolor texture
  use_dome_tex: bool = false
  tex_resolution: integer = 512
  dome_targetRadius: float = 100
  dome_emitRadius: float = 150
  dome_spherical: bool = false
  tex_adaptive: float = 1
  dome_rayDistance: float = 100000
  dome_rayDistanceMode: integer = 0


Parameters for plugin 'LightDirect'
  enabled: bool = true, true if the light is casting light (turned on) and false otherwise; it only makes sense to use this parameter if it is animated, or if another object depends on this node but it must not be rendered
  transform: transform
  color: color = Color(1, 1, 1), Color of the light
  color_tex: acolor texture, A color texture that if present will override the color parameter
  shadows: bool = true, true if the light casts shadows and false otherwise
  shadowColor: color = Color(0, 0, 0), The shadow color. Anything but black is not physically accurate.
  shadowColor_tex: acolor texture, A color texture that if present will override the shadowColor parameter
  shadowBias: float = 0, Shadow offset from the surface. Helps to prevent polygonal shadow artifacts on low-poly surfaces.
  photonSubdivs: integer = 500
  causticSubdivs: integer = 1000
  diffuseMult: float = 1, Multiplier for the diffuse photons.
  causticMult: float = 1, Multiplier for the caustic photons.
  cutoffThreshold: float = 0.001, Light cut-off threshold (speed optimization). If the light intensity for a point is below this threshold, the light will not be computed.
  affectDiffuse: bool = true, true if the light produces diffuse lighting and false otherwise
  affectSpecular: bool = true, true if the light produces specular hilights and false otherwise
  bumped_below_surface_check: bool = false, true if the bumped normal should be used to check if the light dir is below the surface
  nsamples: integer = 0, Number of parameter samples for motion blur.
  diffuse_contribution: float = 1, Diffuse contribution for the light
  specular_contribution: float = 1, Specular contribution for the light
  channels: plugin, unlimited list, Render channels the result of this light will be written to
  channels_raw: plugin, unlimited list, Render channels the raw diffuse result of this light will be written to
  channels_diffuse: plugin, unlimited list, Render channels the diffuse result of this light will be written to
  channels_specular: plugin, unlimited list, Render channels the specular result of this light will be written to
  use_global_light_level: bool = true, true if the light should use the global light level setting
  units: integer = 0, Units for the intensity (0 - default, 1 - lumens, 2 - lm/m/m/sr, 3 - watts, 4 - w/m/m/sr)
  intensity: float = 1, Light intensity
  intensity_tex: float texture, A float texture that if present will override the intensity parameter
  shadowRadius: float = 0, The size of the light; 0.0 is a point light, larger values produces soft (area) shadows
  areaSpeculars: bool = false, If true, the hilights will match the shape of the light; if false, hilights will always be calculated as from a point light
  shadowSubdivs: integer = 8
  beamRadius: float = 0, 0.0 if the light has no beam radius


Parameters for plugin 'Instancer'
  instances: list
  nsamples: integer = 0, Number of transform samples
  visible: bool = true


Parameters for plugin 'GeomStaticSmoothedMesh'
  mesh: plugin, The triangle mesh that will be displaced
  displacement_tex_color: acolor texture, The displacement texture
  displacement_tex_float: float texture, The displacement texture
  displacement_amount: float = 1, Determines the displacement amount for white areas in the displacement map; if use_globals is true this is multiplied by the global displacement amount option.
  displacement_shift: float = 0, This constant value is added to the displacement map
  keep_continuity: bool = false, If true, the plugin will attempt to keep the continuity of the displaced surface
  water_level: float = -1e+30, Geometry below this displacement level will be clipped away
  use_globals: bool = true, If true, the global displacement quality settings will be used.
  view_dep: integer = 1, If use_globals is false, this determines if view-dependent tesselation is used
  edge_length: float = 4, If use_globals is false, this determines the approximate edge length for the sub-triangles
  max_subdivs: integer = 256, If use_globals is false, this determines the maximum subdivisions for a triangle of the original mesh
  use_bounds: bool = false, If true, the min/max values for the displacement texture are specified by the min_bound and max_bound parameters; if false, these are calculated automatically.
  min_bound: color = Color(0, 0, 0), The lowest value for the displacement texture
  max_bound: color = Color(1, 1, 1), The biggest value for the displacement texture


Parameters for plugin 'TrimmingRegion'
  innerCurves: plugin, unlimited list, List of NURBSCurve objects - the inner curves for the trimming region
  outerCurve: plugin, A NURBSCurve object - the outer curve for the trimming region


Parameters for plugin 'TrimmingRegionsComplex'
  count: integer, unlimited list, List containing information about the number of regions, number of boundaries within them, number of curves for a boundary, the curves' number of cvs, knots and degree
  cvs: float, unlimited list, List containg pairs of (u, v) coordinates of control vertices for all the curves
  knots: float, unlimited list, List containing the knot values for all the curves


Parameters for plugin 'NURBSCurve'
  degree: integer = 3, Degree of the curve
  cvs: vector, unlimited list, The control vertices of the curve
  knotVector: float, unlimited list, The knots vector for the curve
  boundary: bool, unlimited list, Mark curve as island or hole


Parameters for plugin 'GeomStaticNURBS'
  cvs: vector, unlimited list, List of lists with the CVs of the NURBS.
  weights: float, unlimited list, List of lists with the weights for the NURBS's CVs.
  trims: plugin, unlimited list, List of TrimmingRegion objects. The orientation is used to determine whether the trim will generate geometry inside of it or outside of it
  listTrimCurves: plugin, unlimited list, List of NURBSCurve objects - the trimming curves
  trimsComplex: plugin, A single plug-in containing all the trim information.
  uKnots: float, unlimited list, U direction knot values
  vKnots: float, unlimited list, V direction knot values
  maxSubdivDepth: integer = 5
  flatnessCoef: float = 0.01
  regularSubdiv: bool = false
  regularUSteps: integer = 20
  regularVSteps: integer = 20
  uDirectionType: integer = 0
  vDirectionType: integer = 0
  uDegree: integer = 3
  vDegree: integer = 3
  flipNormals: bool = false
  generateStatic: bool = false
  primary_visibility: bool = true


Parameters for plugin 'GeomStaticMesh'
  vertices: vector, unlimited list
  faces: integer, unlimited list
  normals: vector, unlimited list
  faceNormals: integer, unlimited list
  map_channels: list, unlimited list, A list of mapping channels; each channel itself is a list of 3 elements - the channel index, the channel vertices and the channel faces.
  edge_visibility: integer, unlimited list, A list of edge visibility flags, each integer in the list has edge visibility information for 10 consecutive faces
  face_mtlIDs: integer, unlimited list, Material IDs for each face
  smooth_derivs: list, unlimited list, A list of mapping channels with smooth derivs; this can also be a single boolean value to specify whether all channels are smooth.
  weld_threshold: float = -1, If this parameter is present, the vertices of the mesh which are within the given threshold of one another will be welded. If absent or negative, no welding is performed.
  reference_mesh: plugin, The reference mesh which is used to calculate the uvw coordinates when a 3d placement is used.
  reference_transform: transform, The transform of the reference mesh.
  primary_visibility: bool = true, If off shading an intersection with this mesh will not generate a gbuffer.
  dynamic_geometry: bool = false, When this flag is true V-Ray will use dynamic geometry for this mesh(instead of copying the mesh many times in the BSP tree, only the bounding box will be present many times and ray intersections will occur in a separate object space BSP tree)
  environment_geometry: bool = false, When this flag is true V-Ray will use this geometry as part of the background(for example, this will be included in matte objects.
  smooth_uv_borders: bool = true, true to smooth UVs at mesh borders when rendering this mesh as a subdivision surface
  smooth_uv: bool = true, true to smooth UVs when rendering this mesh as a subdivision surface


Parameters for plugin 'GeomDisplacedMesh'
  mesh: plugin, The triangle mesh that will be displaced
  displacement_tex_color: acolor texture, The displacement texture
  displacement_tex_float: float texture, The displacement texture
  displacement_amount: float = 1, Determines the displacement amount for white areas in the displacement map; if use_globals is true this is multiplied by the global displacement amount option.
  displacement_shift: float = 0, This constant value is added to the displacement map
  use_globals: bool = true, If true, the global displacement quality settings will be used.
  view_dep: integer = 1, If use_globals is false, this determines if view-dependent tesselation is used
  edge_length: float = 4, If use_globals is false, this determines the approximate edge length for the sub-triangles
  max_subdivs: integer = 256, If use_globals is false, this determines the maximum subdivisions for a triangle of the original mesh
  keep_continuity: bool = false, If true, the plugin will attempt to keep the continuity of the displaced surface
  water_level: float = -1e+30, Geometry below this displacement level will be clipped away
  vector_displacement: bool = false, When this is true, the red, green and blue channels of displacement_tex_color will be used to perform vector displacement.
  map_channel: integer = 0, The mapping channel to use for vector and 2d displacement.
  use_bounds: bool = false, If true, the min/max values for the displacement texture are specified by the min_bound and max_bound parameters; if false, these are calculated automatically.
  min_bound: color = Color(0, 0, 0), The lowest value for the displacement texture
  max_bound: color = Color(1, 1, 1), The biggest value for the displacement texture
  displace_2d: bool = false, Use to enable 2d displacement. Overrides the vector_displacement flag.
  resolution: integer = 256, Resolution at which to sample the displacement map for 2d displacement.
  precision: integer = 8, Increase for curved surfaces to avoid artifacts.
  tight_bounds: integer = 0, When this is on, initialization will be slower, but tighter bounds will be computed for the displaced triangles making rendering faster.
  filter_texture: bool = false, Filter the texture for 2d displacement.
  filter_blur: float = 0.001, The amount of UV space to average for filtering purposes. A value of 1.0 will average thw whole texture.


Parameters for plugin 'GeomPlane'


Parameters for plugin 'GeomParticleSystem'
  mesh: plugin, The triangle mesh that will be instanced.This is used only for some of the particle render types.
  render_type: integer = 7, 3 - multipoints; 4 - multistreak; 6 - points; 7 - Spheres; 8 - Sprites; 9 - Streak.Everything else gives a warning and renders as spheres.
  positions: vector, unlimited list, The positions of the particles.
  velocities: vector, unlimited list, The velocities of the particles. This is in world units per frame.
  ids: integer, unlimited list, The particle ids. Some particles may disappear so we need these when storing moving triangles in MovingParticleGeomGen.
  radii: float, unlimited list, The particle radii when the particles are spheres.
  acceleration_pp: color, unlimited list, Per-particle acceleration.
  colors: color, unlimited list, Per-particle diffuse color.
  emission_pp: color, unlimited list, Per-particle emission color.
  user_color_pp_1: color, unlimited list, Corresponds to Maya's userVector1PP.
  user_color_pp_2: color, unlimited list, Corresponds to Maya's userVector2PP.
  user_color_pp_3: color, unlimited list, Corresponds to Maya's userVector3PP.
  user_color_pp_4: color, unlimited list, Corresponds to Maya's userVector4PP.
  user_color_pp_5: color, unlimited list, Corresponds to Maya's userVector5PP.
  age_pp: float, unlimited list, Per-particle age.
  lifespan_pp: float, unlimited list, Per-particle lifespan.
  opacity_pp: float, unlimited list, Per-particle opacity.
  user_float_pp_1: float, unlimited list, Corresponds to Maya's userScalar1PP.
  user_float_pp_2: float, unlimited list, Corresponds to Maya's userScalar2PP.
  user_float_pp_3: float, unlimited list, Corresponds to Maya's userScalar3PP.
  user_float_pp_4: float, unlimited list, Corresponds to Maya's userScalar4PP.
  user_float_pp_5: float, unlimited list, Corresponds to Maya's userScalar5PP.
  sprite_size_x: float = 1, The width of sprite particles in world units.
  sprite_size_y: float = 1, The height of sprite particles in world units.
  sprite_twist: float = 0, The twist of sprite particles in degrees.
  point_size: float = 1, The size of point and multipoint particles, in pixels.
  multi_count: integer = 1, The number of particles generated for each input particle, when the render type is multipoints or multistreaks.
  multi_radius: float = 0, The maximum distance between the original and a generated particle when the render type is multipoints or multistreaks.
  line_width: float = 1, The width of streak particles, in pixels
  tail_length: float = 1, The length of streak particles, in world units, the actual length depends on the particle velocity as well.
  primary_visibility: bool = true, If off, shading an intersection with this mesh will not generate a gbuffer.


Parameters for plugin 'GeomMeshTest'
  sphere_size: float = 3, Sphere size
  sphere_segments: integer = 10, Sphere segments
  num_spheres: integer = 100, Number of spheres
  bbox_size: float = 30, Box size to fill with spheres


Parameters for plugin 'GeomMeshLoader1'
  sphere_size: float = 3, Sphere size
  sphere_segments: integer = 10, Sphere segments
  num_spheres: integer = 100, Number of spheres
  bbox_size: float = 30, Box size to fill with spheres


Parameters for plugin 'GeomMeshLoader'
  sphere_size: float = 3, Sphere size
  sphere_segments: integer = 10, Sphere segments
  num_spheres: integer = 100, Number of spheres
  bbox_size: float = 30, Box size to fill with spheres


Parameters for plugin 'GeomMeshFile'
  file: string = ""
  anim_speed: float = 1, Animated proxy playback speed
  anim_type: integer = 0, Animated proxy playback type (0 - loop; 1 - once; 2 - ping-pong; 3 - still)
  anim_offset: float = 0, Animated proxy initial frame offset
  primary_visibility: bool = true
  scale: float = 1, Size scaling factor


Parameters for plugin 'GeomMayaHair'
  num_hair_vertices: integer, unlimited list, A list of the number of hair vertices, one for each hair strand.
  hair_vertices: vector, unlimited list, A list with the positions of the hair vertices in object space. The number of elements should be equal to the sum of the elements of the num_hair_vertices parameter.
  widths: float, unlimited list, The width of the hair strands at each vertex.Should have the same number of elements as hair_vertices.
  colors: color, unlimited list, Color values for each hair vertex.Should have the same number of elements as hair_vertices.
  incandescence: color, unlimited list, Incandescence values for each hair vertex.Should have the same number of elements as hair_vertices.
  transparency: color, unlimited list, Transparency values for each hair vertex.Should have the same number of elements as hair_vertices.
  opacity: float = 1, The Maya hair shader does not allow for different transparency on each hair vertex. Instead it uses a single opacity parameter for all of them.


Parameters for plugin 'GeomHair'
  mesh: plugin, The triangle mesh that will have hairs generated on it.
  length_base: float = 100, The base hair length.
  thickness_base: float = 0.01, The base hair thickness.
  gravity_base: float = 10, The base gravity.
  gravity_vector: vector = Color(0, 0, 0), The gravity force direction vector.
  dir_var: float = 0, The direction variation.
  length_var: float = 0, The hair length variation.
  thickness_var: float = 0, The hair thickness variation.
  gravity_var: float = 0, The gravity variation.
  bend: float = 0, The amount of hair bending.
  taper: float = 0, The amount of taper applied to hairs.
  hair_sides: integer = 3, Number of segments along the circumference of a single hair.
  hair_knots: integer = 8, Number of segments along the length of a single hair.
  faceList: integer, unlimited list, A list of face indices that will have hair generated on them. If NULL all faces will have hair on them.
  fixed_areas: integer = 0, True if areaList should be used to determine the number of hairs when distribution is 'per area'.
  areaList: float, unlimited list, A list of triangle surface areas. An element here corresponds to an element in faceList, if faceList is not NULL. 
  distribution: integer = 0, 0 : per face; 1 : per area
  perFace: integer = 10, Number of hairs per face if distribution==0
  perArea: float = 10, Number of hairs per unit area if distribution==1
  flat_normals: integer = 0
  map_channel: integer = 0, Map channel to derive the uv space from.
  bend_direction_tex: acolor texture = AColor(0, 0, 0, 1), A texture for the bend direction of hair strands.
  initial_direction_tex: acolor texture = AColor(0, 0, 0, 1), A texture for the initial direction of hair strands.
  length_tex: float texture = 0, A texture for the length.
  thickness_tex: float texture = 0, A texture for the thickness.
  gravity_tex: float texture = 0, A texture for the gravity.
  bend_tex: float texture = 0, A texture for the bend.
  density_tex: float texture = 0, A texture for the density.


Parameters for plugin 'GeomBox'
  size_x: float = 1, The size in the X direction
  size_y: float = 1, The size in the X direction
  size_z: float = 1, The size in the X direction
  is_volumetric: bool = false, true to handle the case when the camera is inside the box


Parameters for plugin 'CameraPhysical'
  type: integer = 0, 0-still camera; 1-movie camera; 2- video camera
  film_width: float = 36, film gate in mm
  focal_length: float = 40, focal length in mm
  zoom_factor: float = 1, zoom factor
  distortion: float = 0, distortion
  distortion_type: integer = 0, 0-quadratic; 1-cubic; 2-lens file
  f_number: float = 8, f-stop
  lens_shift: float = 0, lens shift
  shutter_speed: float = 300, the shutter speed
  shutter_angle: float = 180, shutter angle in degrees
  shutter_offset: float = 0, shutter offset in degrees
  latency: float = 0
  ISO: float = 200
  specify_focus: bool = false
  focus_distance: float = 200, focus distance in mm
  targeted: bool = true, 1-specify a target distance; 0-target distance not specified
  target_distance: float = 200, target distance
  dof_display_threshold: float = 0.001, display threshold for depth-of-field
  exposure: bool = true, 1- exposure color correction; 0-disable exposure color correction
  white_balance: color = Color(1, 1, 1)
  vignetting: float = 1, Strength of vignetting effect
  blades_enable: bool = false, 1- enable Bokeh effects; 0- disable Bokeh effects
  blades_num: integer = 5, number of blades - 0 means its disabled
  blades_rotation: float = 0, blade rotation in radians
  center_bias: float = 0, center bias
  anisotropy: float = 0, Bokeh anisotropy
  use_dof: bool = false
  use_moblur: bool = false
  subdivs: integer = 6
  dont_affect_settings: bool = false, This is here so we can suppress a PhysicalCamera node from affecting the main VRayRenderer sequence and frame data.
  lens_file: string = "", LENS file with camera lens-type image distortion description
  specify_fov: bool = false, true to use explicit field of view and false to use the focal length
  fov: float = 1.5708, the FOV value (in radians) to use when specify_fov is true
  horizontal_shift: float = 0, the horizontal lens shift
  horizontal_offset: float = 0, The horizontal offset
  vertical_offset: float = 0, The vertical offset


Parameters for plugin 'CameraFilmTransform'
  prescale: float = 1, The prescale that will be applied to the camera
  postscale: float = 1, The postScale that will be applied to the camera
  transx: float = 0, The normalized translation along x axis that will be applied to the camera
  transy: float = 0, The normalized translation along y axis that will be applied to the camera
  pivotx: float = 0, The rotation pivot y coordinate
  pivoty: float = 0, The rotation pivot x coordinate
  rotation: float = 0, The rotation around the pivot that will be applied to the camera
  rot_before_trans: bool = true, If true, the rotation will be applied before the translation


Parameters for plugin 'CameraDome'
  flip_x: bool = false, Flip in the horizontal image direction
  flip_y: bool = false, Flip in the vertical image direction
  fov: float = 0.785398, Field of view (radians)


Parameters for plugin 'RawBitmapBuffer'
  filter_type: integer = 1, 0 - no filtering; 1 - mip-map filtering; 2 - summed area table filtering
  filter_blur: float = 1
  color_space: integer = 1, 0 - linear, 1 - gamma corrected, 2 - sRGB
  gamma: float = 1
  maya_compatible: bool = false
  allow_negative_colors: bool = false, if false negative colors will be clamped
  interpolation: integer = 0, Interpolation method for the mip-map filtering (0 - bilinear, 1 - bicubic)
  pixels: integer = 0, The raw pixels used in the bitmap
  pixels_type: integer = 0, 0: 8-bit RGBA, 2: 8-bit RGBE, 3: 16-bit RGBA, 4: float RGBA
  width: integer = 0, The widht of the raw bitmap
  height: integer = 0, The height of the raw bitmap


Parameters for plugin 'BitmapBuffer'
  filter_type: integer = 1, 0 - no filtering; 1 - mip-map filtering; 2 - summed area table filtering
  filter_blur: float = 1
  color_space: integer = 1, 0 - linear, 1 - gamma corrected, 2 - sRGB
  gamma: float = 1
  maya_compatible: bool = false
  allow_negative_colors: bool = false, if false negative colors will be clamped
  interpolation: integer = 0, Interpolation method for the mip-map filtering (0 - bilinear, 1 - bicubic)
  file: string = "", The file name; can contain <UDIM> or <UVTILE> tags for Mari or Mudbox tiles respectively
  frame_sequence: bool = false
  frame_number: integer = 0
  frame_offset: integer = 0
  use_data_window: bool = true, true to use the data window information in e.g. OpenEXR files; otherwise false
  psd_group_name: integer, unlimited list
  psd_alpha_name: integer, unlimited list
  ifl_start_frame: integer = 0
  ifl_playback_rate: float = 1
  ifl_end_condition: integer = 0, Image file list (IFL) end condition: 0 - Loop; 1 - Ping Pong; 2 - Hold;


Parameters for plugin 'BakeView'
  bake_node: plugin, The node to bake
  bake_uvwgen: plugin, The uvw generator
  dilation: float = 2, Number of pixels to expand around geometry
  flip_derivs: bool = false, true to flip the texture direction derivatives (reverses bump mapping)


Parameters for plugin 'BRDFVRayMtl'
  opacity: float texture = 1, The opacity of the material
  diffuse: acolor texture = AColor(0.5, 0.5, 0.5, 1), The diffuse color of the material
  roughness: float texture = 0, The roughness of the diffuse part of the material
  brdf_type: integer = 1, The BRDF type (0 - Phong, 1 - Blinn, 2 - Ward)
  reflect: acolor texture = AColor(0, 0, 0, 1), The reflection color of the material
  reflect_glossiness: float texture = 1, The glossiness of the reflections
  hilight_glossiness: float texture = 1, The glossiness of the hilights
  hilight_glossiness_lock: bool = true, true to use the reflection glossiness also for hilights (hilight_glossiness is ignored)
  fresnel: bool = false, true to enable fresnel reflections
  fresnel_ior: float texture = 1.6, The ior for calculating the Fresnel term
  fresnel_ior_lock: bool = true, true to use the refraction ior also for the Fresnel term (fresnel_ior is ignored)
  reflect_subdivs: integer = 8, Subdivs for glossy reflectons
  reflect_trace: bool = true, true to trace reflections and false to only do hilights
  reflect_depth: integer = 5, The maximum depth for reflections
  reflect_exit_color: color = Color(0, 0, 0), The color to use when the maximum depth is reached
  hilight_soften: float = 0, How much to soften hilights and reflections at grazing light angles
  reflect_dim_distance: float = 1e+18, How much to dim reflection as length of rays increases
  reflect_dim_distance_on: bool = false, True to enable dim distance
  reflect_dim_distance_falloff: float = 0, Fall off for the dim distance
  anisotropy: float texture = 0, The anisotropy for glossy reflections, from -1 to 1 (0.0 is isotropic reflections)
  anisotropy_rotation: float texture = 0, The rotation of the anisotropy axes, from 0.0 to 1.0
  anisotropy_derivation: integer = 0, What method to use for deriving anisotropy axes (0 - local object axis; 1 - a specified uvw generator)
  anisotropy_axis: integer = 2, Which local object axis to use when anisotropy_derivation is 0
  anisotropy_uvwgen: plugin, The uvw generator to use for anisotropy when anisotropy_derivation is 1
  refract: acolor texture = AColor(0, 0, 0, 1), The refraction color of the material
  refract_ior: float texture = 1.6, The IOR for refractions
  refract_glossiness: float texture = 1, Glossiness for refractions
  refract_subdivs: integer = 8, Subdivs for glossy refractions
  refract_trace: bool = true, 1 to trace refractions; 0 to disable them
  refract_depth: integer = 5, The maximum depth for refractions
  refract_exit_color: color = Color(0, 0, 0), The color to use when maximum depth is reached when refract_exit_color_on is true
  refract_exit_color_on: bool = false, If false, when the maximum refraction depth is reached, the material is assumed transparent, instead of terminating the ray
  refract_affect_alpha: integer = 0, Determines how refractions affect the alpha channel (0 - opaque alpha; 1 - alpha is taken from refractions; 2 - all channels are propagated
  refract_affect_shadows: bool = false, true to enable the refraction to affect the shadows cast by the material (as transparent shadows)
  dispersion_on: bool = false, true to enable dispersion
  dispersion: float = 50, abbe value
  fog_color: color = Color(1, 1, 1), The absorption (fog) color
  fog_mult: float = 1, Multiplier for the absorption
  fog_bias: float = 0, Bias for the absorption
  fog_unit_scale_on: bool = true, Enable unit scale multiplication, when calculating absorption
  translucency: integer = 0, Translucency mode (0 - none)
  translucency_color: acolor texture = AColor(1, 1, 1, 1), Filter color for the translucency effect
  translucency_light_mult: float = 1, A multiplier for the calculated lighting for the translucency effect
  translucency_scatter_dir: float = 0.5, Scatter direction (0.0f is backward, 1.0f is forward)
  translucency_scatter_coeff: float = 0, Scattering cone (0.0f - no scattering, 1.0f - full scattering
  translucency_thickness: float = 1e+18, Maximum distance to trace inside the object
  option_double_sided: bool = true, true if the material is double-sided
  option_reflect_on_back: bool = false, true to compute reflections for back sides of objects
  option_glossy_rays_as_gi: integer = 1, Specifies when to treat GI rays as glossy rays (0 - never; 1 - only for rays that are already GI rays; 2 - always
  option_cutoff: float = 0.001, Specifies a cutoff threshold for tracing reflections/refractions
  option_use_irradiance_map: bool = true, false to perform local brute-force GI calculatons and true to use the current GI engine
  option_energy_mode: integer = 0, Energy preservation mode for reflections and refractions (0 - color, 1 - monochrome)
  option_fix_dark_edges: integer = 1, true to fix dark edges for glossy reflections with low samples; only set this to false for compatibility with older versions
  environment_override: acolor texture, Environment override texture
  environment_priority: integer = 0, Environment override priority (used when several materials override it along a ray path)


Parameters for plugin 'BRDFSampled'
  color: color = Color(1, 1, 1)
  color_tex: acolor texture
  color_tex_mult: float = 1
  transparency: color = Color(0.5, 0.5, 0.5)
  transparency_tex: acolor texture
  transparency_tex_mult: float = 1
  cutoff: float = 0.01
  subdivs: integer = 8
  back_side: bool = false
  brdf_bitmap: plugin
  brdf_nsamples_d_theta: integer = 0, Number of d_theta samples
  brdf_nsamples_d_phi: integer = 1, Number of d_phi samples (1 means isotropic BRDF)
  brdf_importance_sampling_on: bool = true, true to use importance sampling for the reflections
  brdf_importance_sampling_resolution: integer = 32, Resolution for the resampling of the BRDF used for importance sampling of reflections
  brdf_importance_sampling_view_terms: integer = 4, Number of terms to decompose the view-dependent portion of the resampling matrix
  brdf_importance_sampling_half_terms: integer = 2, Number of terms to decompose the half-angle portion of the resampling matrix


Parameters for plugin 'BRDFSSS2Complex'
  prepass_rate: integer = -1, Sampling density for the illumination map
  interpolation_accuracy: float = 1, Interpolation accuracy for the illumination map; normally 1.0 is fine.
  scale: float = 1, Values below 1.0 will make the object look as if it is bigger. Values above 1.0 will make it look as if it is smaller
  ior: float = 1.5
  overall_color: acolor texture = AColor(1, 1, 1, 1)
  diffuse_color: acolor texture = AColor(0.5, 0.5, 0.5, 1)
  diffuse_amount: float texture = 0
  sub_surface_color: acolor texture = AColor(0.5, 0.5, 0.5, 1)
  scatter_radius: acolor texture = AColor(0.92, 0.52, 0.175, 1), This is measured in centimeters
  scatter_radius_mult: float texture = 2, The scatter radius will be multiplied by this number
  phase_function: float = 0
  specular_color: acolor texture = AColor(1, 1, 1, 1)
  specular_amount: float texture = 1
  specular_glossiness: float texture = 0.6
  specular_subdivs: integer = 8
  cutoff_threshold: float = 0.01
  trace_reflections: bool = false
  reflection_depth: integer = 5
  single_scatter: integer = 1
  subdivs: integer = 8, Single scatter subdivisions
  refraction_depth: integer = 5
  front_scatter: bool = true
  back_scatter: bool = true
  scatter_gi: bool = false
  prepass_blur: float = 1.2
  channels: plugin, unlimited list, Render channels the result of this BRDF will be written to


Parameters for plugin 'BRDFSSS2'
  prepass_rate: integer = -1, Sampling density for the illumination map
  interpolation_accuracy: float = 1, Interpolation accuracy for the illumination map; normally 1.0 is fine.
  scale: float = 1, Values below 1.0 will make the object look as if it is bigger. Values above 1.0 will make it look as if it is smaller
  ior: float = 1.5
  diffuse_reflectance: acolor texture = AColor(0.81, 0.81, 0.69, 1)
  scatter_radius: acolor texture = AColor(0.92, 0.52, 0.175, 1), This is measured in centimeters
  scatter_radius_mult: float texture = 2, The scatter radius will be multiplied by this number
  subdivs: integer = 8
  phase_function: float = 0
  single_scatter: integer = 1
  front_scatter: bool = true
  back_scatter: bool = true
  scatter_gi: bool = false
  prepass_lod_threshold: float = 4
  prepass_blur: float = 1.2


Parameters for plugin 'BRDFSSS'
  color: color = Color(1, 1, 1)
  color_tex: acolor texture
  color_tex_mult: float = 1
  translucency: color = Color(1, 1, 1)
  translucency_tex: acolor texture
  translucency_tex_mult: float = 1
  glossiness: float = 0
  glossiness_tex: float texture
  glossiness_tex_mult: float = 1
  subdivs: integer = 8
  thickness: float = 1e+18
  scatter_coeff: float = 0
  scatter_direction: float = 1


Parameters for plugin 'BRDFPhong'
  color: color = Color(1, 1, 1)
  color_tex: acolor texture
  color_tex_mult: float = 1
  transparency: color = Color(0, 0, 0)
  transparency_tex: acolor texture
  transparency_tex_mult: float = 1
  cutoff: float = 0.01
  back_side: bool = false
  trace_reflections: bool = true
  trace_depth: integer = -1, The maximum reflection depth (-1 is controlled by the global options)
  reflect_exit_color: acolor texture = AColor(0, 0, 0, 0), The color to use when the maximum depth is reached
  reflect_dim_distance: float = 1e+18, How much to dim reflection as length of rays increases
  reflect_dim_distance_on: bool = false, True to enable dim distance
  reflect_dim_distance_falloff: float = 0, Fall off for the dim distance
  hilightGlossiness: float = 0.8
  hilightGlossiness_tex: float texture
  hilightGlossiness_tex_mult: float = 1
  reflectionGlossiness: float = 0.8
  reflectionGlossiness_tex: float texture
  reflectionGlossiness_tex_mult: float = 1
  subdivs: integer = 8
  glossyAsGI: integer = 1, Determines if the glossy rays are treated by V-Ray as GI rays: 0 - never; 1 - only for rays that are already marked as GI rays; 2 - always
  soften_edge: float = 0, Soften edge of the BRDF at light/shadow transition
  interpolation_on: integer = 0
  imap_min_rate: integer = -1
  imap_max_rate: integer = 1
  imap_color_thresh: float = 0.25
  imap_norm_thresh: float = 0.4
  imap_samples: integer = 20


Parameters for plugin 'BRDFMirror'
  color: color = Color(1, 1, 1)
  color_tex: acolor texture
  color_tex_mult: float = 1
  transparency: color = Color(0, 0, 0)
  transparency_tex: acolor texture
  transparency_tex_mult: float = 1
  cutoff: float = 0.01
  back_side: bool = false
  trace_reflections: bool = true
  trace_depth: integer = -1, The maximum reflection depth (-1 is controlled by the global options)
  reflect_exit_color: acolor texture = AColor(0, 0, 0, 0), The color to use when the maximum depth is reached
  reflect_dim_distance: float = 1e+18, How much to dim reflection as length of rays increases
  reflect_dim_distance_on: bool = false, True to enable dim distance
  reflect_dim_distance_falloff: float = 0, Fall off for the dim distance


Parameters for plugin 'BRDFLight'
  color: acolor texture, The self-illumination color
  colorMultiplier: float texture = 1, Color Multiplier
  transparency: acolor texture, Transparency of the BRDF
  doubleSided: bool = false, If false, the light color is black for back-facing surfaces
  emitOnBackSide: bool = true, Emit on back side
  channels: plugin, unlimited list, Render channels the result of this BRDF will be written to
  compensateExposure: bool = false, Compensate camera exposure


Parameters for plugin 'BRDFLayered'
  brdfs: plugin, unlimited list
  weights: plugin, unlimited list
  transparency: color = Color(0, 0, 0)
  transparency_tex: acolor texture
  transparency_tex_mult: float = 1
  additive_mode: bool = false
  channels: plugin, unlimited list, Render channels the result of this BRDF will be written to


Parameters for plugin 'BRDFHair'
  specular_color_tex: acolor texture
  specular_power: float = 1
  diffuse_color_tex: acolor texture


Parameters for plugin 'BRDFGlassGlossy'
  color: color = Color(1, 1, 1)
  color_tex: acolor texture
  color_tex_mult: float = 1
  transparency: color = Color(0, 0, 0)
  transparency_tex: acolor texture
  transparency_tex_mult: float = 1
  ior: float = 1.55, IOR for the glass; this is ignored if the surface has a volume shader (the volume IOR is used).
  cutoff: float = 0.01
  affect_shadows: bool = false
  affect_alpha: integer = 0, Specifies how render channels are propagated through the glass (0 - only the color channel; 1 - color and alpha; 2 - all channels
  trace_refractions: bool = true
  trace_depth: integer = -1, The maximum refraction bounces (-1 is controlled by the global options)
  exit_color_on: bool = false
  reflect_exit_color: acolor texture = AColor(0, 0, 0, 0), The color to use when the maximum depth is reached
  refract_exit_color: acolor texture = AColor(0, 0, 0, 0), The color to use when maximum depth is reached when exit_color_on is true
  volume: plugin
  glossiness: float = 0.8
  glossiness_tex: float texture
  glossiness_tex_mult: float = 1
  subdivs: integer = 8
  dispersion_on: integer = 0
  dispersion: float = 1
  interpolation_on: integer = 0
  imap_min_rate: integer = -1
  imap_max_rate: integer = 1
  imap_color_thresh: float = 0.25
  imap_norm_thresh: float = 0.4
  imap_samples: integer = 20


Parameters for plugin 'BRDFGlass'
  color: color = Color(1, 1, 1)
  color_tex: acolor texture
  color_tex_mult: float = 1
  transparency: color = Color(0, 0, 0)
  transparency_tex: acolor texture
  transparency_tex_mult: float = 1
  ior: float = 1.55, IOR for the glass; this is ignored if the surface has a volume shader (the volume IOR is used).
  cutoff: float = 0.01
  affect_shadows: bool = false
  affect_alpha: integer = 0, Specifies how render channels are propagated through the glass (0 - only the color channel; 1 - color and alpha; 2 - all channels
  trace_refractions: bool = true
  trace_depth: integer = -1, The maximum refraction bounces (-1 is controlled by the global options)
  exit_color_on: bool = false
  reflect_exit_color: acolor texture = AColor(0, 0, 0, 0), The color to use when the maximum depth is reached
  refract_exit_color: acolor texture = AColor(0, 0, 0, 0), The color to use when maximum depth is reached when exit_color_on is true
  volume: plugin


Parameters for plugin 'BRDFDiffuse_forSSS'
  color: color = Color(1, 1, 1)
  color_tex: acolor texture
  color_tex_mult: float = 1
  transparency: color = Color(0, 0, 0)
  transparency_tex: acolor texture
  transparency_tex_mult: float = 1
  back_color: acolor texture = AColor(1, 1, 1, 1), Color on the back sides of the material
  roughness: float texture
  use_irradiance_map: bool = true


Parameters for plugin 'BRDFDiffuse'
  color: color = Color(1, 1, 1)
  color_tex: acolor texture
  color_tex_mult: float = 1
  transparency: color = Color(0, 0, 0)
  transparency_tex: acolor texture
  transparency_tex_mult: float = 1
  roughness: float texture
  use_irradiance_map: bool = true


Parameters for plugin 'BRDFCarPaint'
  base_color: acolor texture = AColor(0.3, 0.4, 0.5, 1)
  base_reflection: float texture = 0.5
  base_glossiness: float texture = 0.6
  flake_color: acolor texture = AColor(0.3, 0.4, 0.8, 1)
  flake_glossiness: float texture = 0.8
  flake_orientation: float texture = 0.3
  flake_density: float = 0.5
  flake_scale: float = 0.01
  flake_size: float = 0.5
  flake_map_size: integer = 1024, The size of the internal flakes map
  flake_filtering_mode: integer = 1, Flake filtering mode (0 - simple; 1 - directional)
  flake_seed: integer = 1, The random seed for the flakes
  flake_uvwgen: plugin
  coat_color: acolor texture = AColor(1, 1, 1, 1)
  coat_strength: float texture = 0.05
  coat_glossiness: float texture = 1, The glossiness of the coat layer
  coat_bump_float: float texture, Bump texture for the coat layer
  coat_bump_color: acolor texture, Bump texture for the coat layer (color version)
  coat_bump_amount: float texture, Bump amount for the coat layer
  coat_bump_type: integer = 0, The type of bump mapping (see BRDFBump for more details)
  traceReflections: integer = 1
  doubleSided: integer = 1
  subdivs: integer = 8
  cutoff_threshold: float = 0.001
  mapping_type: integer = 0, The mapping method for the flakes (0 - explicit mapping channel, 1 - triplanar projection in object space)
  mapping_channel: integer = 0, The mapping channel when the mapping_type is 0
  environment_override: acolor texture, Environment override texture
  environment_priority: integer = 0


Parameters for plugin 'BRDFBump'
  base_brdf: plugin, Base BRDF
  bump_tex_color: acolor texture, Bump texture
  bump_tex_float: float texture, Bump texture
  bump_tex_mult: float = 1, Bump amount
  bump_tex_mult_tex: float texture, Bump amount texture
  bump_tex: plugin, Bump texture; this is deprecated, use bump_tex_color or bump_tex_float
  bump_shadows: bool = false, true to offset the surface shading point, in addition to the normal
  map_type: integer = 0, The type of the map (0 - from regular texture output, 1 - normal map in tangent space, 2 - normal map in object space, 3 - normal map in camera space, 4 - normal map in world space, 5 - from texture bump output, 6 - explicit normal)
  normal_uvwgen: plugin, The uvw generator for the normal map texture when map_type is 1.
  maya_compatible: bool = false, When this is true the BRDFBump will try to match the Maya bump/normal mapping
  compute_bump_for_shadows: bool = true, true to compute bump mapping for shadow rays in case the material is transparent; false to skip the bump map for shadow rays (faster rendering)
  bump_delta_scale: float = 1, Scale for sampling the bitmap when map_type is 0. Normally this is tied to the ray differentials, but can be changed if necessary.


Parameters for plugin 'BRDFWard'
  color: color = Color(1, 1, 1)
  color_tex: acolor texture
  color_tex_mult: float = 1
  transparency: color = Color(0, 0, 0)
  transparency_tex: acolor texture
  transparency_tex_mult: float = 1
  cutoff: float = 0.01
  back_side: bool = false
  trace_reflections: bool = true
  trace_depth: integer = -1, The maximum reflection depth (-1 is controlled by the global options)
  reflect_exit_color: acolor texture = AColor(0, 0, 0, 0), The color to use when the maximum depth is reached
  reflect_dim_distance: float = 1e+18, How much to dim reflection as length of rays increases
  reflect_dim_distance_on: bool = false, True to enable dim distance
  reflect_dim_distance_falloff: float = 0, Fall off for the dim distance
  hilightGlossiness: float = 0.8
  hilightGlossiness_tex: float texture
  hilightGlossiness_tex_mult: float = 1
  reflectionGlossiness: float = 0.8
  reflectionGlossiness_tex: float texture
  reflectionGlossiness_tex_mult: float = 1
  subdivs: integer = 8
  glossyAsGI: integer = 1, Determines if the glossy rays are treated by V-Ray as GI rays: 0 - never; 1 - only for rays that are already marked as GI rays; 2 - always
  soften_edge: float = 0, Soften edge of the BRDF at light/shadow transition
  interpolation_on: integer = 0
  imap_min_rate: integer = -1
  imap_max_rate: integer = 1
  imap_color_thresh: float = 0.25
  imap_norm_thresh: float = 0.4
  imap_samples: integer = 20
  anisotropy: float texture, Reflection anisotropy in the range (-1, 1)
  anisotropy_uvwgen: plugin
  anisotropy_rotation: float texture, Anisotropy rotation in the range [0, 1]
  fix_dark_edges: bool = true, true to fix dark edges with glossy reflections; only set this to false for compatibility with older versions


Parameters for plugin 'BRDFBlinn'
  color: color = Color(1, 1, 1)
  color_tex: acolor texture
  color_tex_mult: float = 1
  transparency: color = Color(0, 0, 0)
  transparency_tex: acolor texture
  transparency_tex_mult: float = 1
  cutoff: float = 0.01
  back_side: bool = false
  trace_reflections: bool = true
  trace_depth: integer = -1, The maximum reflection depth (-1 is controlled by the global options)
  reflect_exit_color: acolor texture = AColor(0, 0, 0, 0), The color to use when the maximum depth is reached
  reflect_dim_distance: float = 1e+18, How much to dim reflection as length of rays increases
  reflect_dim_distance_on: bool = false, True to enable dim distance
  reflect_dim_distance_falloff: float = 0, Fall off for the dim distance
  hilightGlossiness: float = 0.8
  hilightGlossiness_tex: float texture
  hilightGlossiness_tex_mult: float = 1
  reflectionGlossiness: float = 0.8
  reflectionGlossiness_tex: float texture
  reflectionGlossiness_tex_mult: float = 1
  subdivs: integer = 8
  glossyAsGI: integer = 1, Determines if the glossy rays are treated by V-Ray as GI rays: 0 - never; 1 - only for rays that are already marked as GI rays; 2 - always
  soften_edge: float = 0, Soften edge of the BRDF at light/shadow transition
  interpolation_on: integer = 0
  imap_min_rate: integer = -1
  imap_max_rate: integer = 1
  imap_color_thresh: float = 0.25
  imap_norm_thresh: float = 0.4
  imap_samples: integer = 20
  anisotropy: float texture, Reflection anisotropy in the range (-1, 1)
  anisotropy_uvwgen: plugin
  anisotropy_rotation: float texture, Anisotropy rotation in the range [0, 1]
  fix_dark_edges: bool = true, true to fix dark edges with glossy reflections; only set this to false for compatibility with older versions


Parameters for plugin 'FilterMitNet'
  size: float = 4, Filter width
  blur: float = 0.333333
  ringing: float = 0.333333


Parameters for plugin 'FilterCookVariable'
  size: float = 3, Filter width


Parameters for plugin 'FilterGaussian'
  size: float = 3, Filter width


Parameters for plugin 'FilterSinc'
  size: float = 4, Filter width


Parameters for plugin 'FilterCatmullRom'


Parameters for plugin 'FilterLanczos'
  size: float = 1.5, Filter width


Parameters for plugin 'FilterTriangle'
  size: float = 1.5, Filter width


Parameters for plugin 'FilterBox'
  size: float = 1.5, Filter width


Parameters for plugin 'FilterArea'
  size: float = 1.5, Filter width


